<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="216" failures="241" skipped="2" tests="995" time="49.404" timestamp="2026-01-20T02:49:23.155916-06:00" hostname="yamaguchi"><testcase classname="" name="src.tests.integration.backend.test_cascor_integration_monitoring" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/backend/test_cascor_integration_monitoring.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/backend/test_cascor_integration_monitoring.py:17: in &lt;module&gt;
    from backend.cascor_integration import CascorIntegration
src/backend/cascor_integration.py:61: in &lt;module&gt;
    from .data_adapter import DataAdapter
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
src/backend/statistics.py:37: in &lt;module&gt;
    from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'</error></testcase><testcase classname="" name="src.tests.integration.backend.test_cascor_integration_paths" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/backend/test_cascor_integration_paths.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/backend/test_cascor_integration_paths.py:15: in &lt;module&gt;
    from backend.cascor_integration import CascorIntegration
src/backend/cascor_integration.py:61: in &lt;module&gt;
    from .data_adapter import DataAdapter
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
src/backend/statistics.py:37: in &lt;module&gt;
    from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'</error></testcase><testcase classname="" name="src.tests.integration.backend.test_cascor_integration_topology" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/backend/test_cascor_integration_topology.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/backend/test_cascor_integration_topology.py:13: in &lt;module&gt;
    from backend.cascor_integration import CascorIntegration
src/backend/cascor_integration.py:61: in &lt;module&gt;
    from .data_adapter import DataAdapter
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
src/backend/statistics.py:37: in &lt;module&gt;
    from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'</error></testcase><testcase classname="" name="src.tests.integration.backend.test_training_monitor" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/backend/test_training_monitor.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/backend/test_training_monitor.py:14: in &lt;module&gt;
    from backend.data_adapter import NetworkTopology, TrainingMetrics
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
src/backend/statistics.py:37: in &lt;module&gt;
    from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'</error></testcase><testcase classname="" name="src.tests.integration.test_api_contracts" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_api_contracts.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_api_contracts.py:19: in &lt;module&gt;
    from fastapi.testclient import TestClient
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.integration.test_api_state_endpoint" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_api_state_endpoint.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_api_state_endpoint.py:20: in &lt;module&gt;
    from fastapi.testclient import TestClient
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.integration.test_apply_button_parameters" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_apply_button_parameters.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_apply_button_parameters.py:20: in &lt;module&gt;
    from backend.training_monitor import TrainingState
src/backend/training_monitor.py:46: in &lt;module&gt;
    from .data_adapter import DataAdapter, NetworkTopology, TrainingMetrics
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
src/backend/statistics.py:37: in &lt;module&gt;
    from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'</error></testcase><testcase classname="" name="src.tests.integration.test_button_layout" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_button_layout.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_button_layout.py:10: in &lt;module&gt;
    from fastapi.testclient import TestClient
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.integration.test_candidate_metrics_stream" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_candidate_metrics_stream.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_candidate_metrics_stream.py:14: in &lt;module&gt;
    from backend.training_monitor import CandidatePool, TrainingState
src/backend/training_monitor.py:46: in &lt;module&gt;
    from .data_adapter import DataAdapter, NetworkTopology, TrainingMetrics
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
src/backend/statistics.py:37: in &lt;module&gt;
    from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'</error></testcase><testcase classname="" name="src.tests.integration.test_cascor_backend_integration" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_cascor_backend_integration.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_cascor_backend_integration.py:32: in &lt;module&gt;
    from backend.cascor_integration import CascorIntegration  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/backend/cascor_integration.py:61: in &lt;module&gt;
    from .data_adapter import DataAdapter
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
src/backend/statistics.py:37: in &lt;module&gt;
    from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'</error></testcase><testcase classname="" name="src.tests.integration.test_cassandra_endpoints" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_cassandra_endpoints.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_cassandra_endpoints.py:21: in &lt;module&gt;
    from fastapi.testclient import TestClient
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.integration.test_constants_integration" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_constants_integration.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_constants_integration.py:18: in &lt;module&gt;
    from frontend.dashboard_manager import DashboardManager
src/frontend/dashboard_manager.py:42: in &lt;module&gt;
    import dash
E   ModuleNotFoundError: No module named 'dash'</error></testcase><testcase classname="" name="src.tests.integration.test_dark_mode" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_dark_mode.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_dark_mode.py:12: in &lt;module&gt;
    from fastapi.testclient import TestClient  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.integration.test_dashboard_e2e" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_dashboard_e2e.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_dashboard_e2e.py:10: in &lt;module&gt;
    from fastapi.testclient import TestClient  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.integration.test_dashboard_enhancements" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_dashboard_enhancements.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_dashboard_enhancements.py:17: in &lt;module&gt;
    from frontend.dashboard_manager import DashboardManager
src/frontend/dashboard_manager.py:42: in &lt;module&gt;
    import dash
E   ModuleNotFoundError: No module named 'dash'</error></testcase><testcase classname="" name="src.tests.integration.test_dashboard_rendering_regression" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_dashboard_rendering_regression.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_dashboard_rendering_regression.py:24: in &lt;module&gt;
    from frontend.components.dataset_plotter import DatasetPlotter
src/frontend/components/dataset_plotter.py:40: in &lt;module&gt;
    import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'</error></testcase><testcase classname="" name="src.tests.integration.test_dashboard_title" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_dashboard_title.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_dashboard_title.py:8: in &lt;module&gt;
    from fastapi.testclient import TestClient  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.integration.test_demo_endpoints" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_demo_endpoints.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_demo_endpoints.py:25: in &lt;module&gt;
    from fastapi.testclient import TestClient
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.integration.test_hdf5_snapshots_api" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_hdf5_snapshots_api.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_hdf5_snapshots_api.py:29: in &lt;module&gt;
    from fastapi.testclient import TestClient  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.integration.test_main_api_endpoints" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_main_api_endpoints.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_main_api_endpoints.py:30: in &lt;module&gt;
    from fastapi.testclient import TestClient  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.integration.test_main_coverage" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_main_coverage.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_main_coverage.py:20: in &lt;module&gt;
    from fastapi.testclient import TestClient
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.integration.test_main_endpoints" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_main_endpoints.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_main_endpoints.py:20: in &lt;module&gt;
    from fastapi.testclient import TestClient
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.integration.test_main_ws" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_main_ws.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_main_ws.py:21: in &lt;module&gt;
    from fastapi.testclient import TestClient
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.integration.test_metrics_layouts_api" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_metrics_layouts_api.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_metrics_layouts_api.py:23: in &lt;module&gt;
    from fastapi.testclient import TestClient
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.integration.test_mvp_functionality" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_mvp_functionality.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_mvp_functionality.py:18: in &lt;module&gt;
    import requests
E   ModuleNotFoundError: No module named 'requests'</error></testcase><testcase classname="" name="src.tests.integration.test_network_stats_endpoint" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_network_stats_endpoint.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_network_stats_endpoint.py:20: in &lt;module&gt;
    from fastapi.testclient import TestClient
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.integration.test_parameter_persistence" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_parameter_persistence.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_parameter_persistence.py:16: in &lt;module&gt;
    from backend.training_monitor import TrainingState
src/backend/training_monitor.py:46: in &lt;module&gt;
    from .data_adapter import DataAdapter, NetworkTopology, TrainingMetrics
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
src/backend/statistics.py:37: in &lt;module&gt;
    from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'</error></testcase><testcase classname="" name="src.tests.integration.test_redis_endpoints" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_redis_endpoints.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_redis_endpoints.py:16: in &lt;module&gt;
    from fastapi.testclient import TestClient
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.integration.test_status_bar_updates" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_status_bar_updates.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_status_bar_updates.py:41: in &lt;module&gt;
    from fastapi.testclient import TestClient  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.integration.test_websocket_message_schema" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_websocket_message_schema.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_websocket_message_schema.py:22: in &lt;module&gt;
    from fastapi.testclient import TestClient
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.integration.test_websocket_state" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_websocket_state.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/integration/test_websocket_state.py:23: in &lt;module&gt;
    from fastapi.testclient import TestClient
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.regression.test_candidate_visibility" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/regression/test_candidate_visibility.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/regression/test_candidate_visibility.py:5: in &lt;module&gt;
    import requests
E   ModuleNotFoundError: No module named 'requests'</error></testcase><testcase classname="" name="src.tests.regression.test_metrics_panel_data_format_regression" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/regression/test_metrics_panel_data_format_regression.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/regression/test_metrics_panel_data_format_regression.py:22: in &lt;module&gt;
    import plotly.graph_objects as go  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   ModuleNotFoundError: No module named 'plotly'</error></testcase><testcase classname="" name="src.tests.unit.frontend.test_about_panel" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/frontend/test_about_panel.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/frontend/test_about_panel.py:24: in &lt;module&gt;
    from dash import html  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^
E   ModuleNotFoundError: No module named 'dash'</error></testcase><testcase classname="" name="src.tests.unit.frontend.test_components_basic" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/frontend/test_components_basic.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/frontend/test_components_basic.py:4: in &lt;module&gt;
    import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'</error></testcase><testcase classname="" name="src.tests.unit.frontend.test_dashboard_helpers_coverage" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/frontend/test_dashboard_helpers_coverage.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/frontend/test_dashboard_helpers_coverage.py:16: in &lt;module&gt;
    import dash
E   ModuleNotFoundError: No module named 'dash'</error></testcase><testcase classname="" name="src.tests.unit.frontend.test_dashboard_manager" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/frontend/test_dashboard_manager.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/frontend/test_dashboard_manager.py:9: in &lt;module&gt;
    from frontend.dashboard_manager import DashboardManager
src/frontend/dashboard_manager.py:42: in &lt;module&gt;
    import dash
E   ModuleNotFoundError: No module named 'dash'</error></testcase><testcase classname="" name="src.tests.unit.frontend.test_dashboard_manager_coverage" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/frontend/test_dashboard_manager_coverage.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/frontend/test_dashboard_manager_coverage.py:11: in &lt;module&gt;
    import dash
E   ModuleNotFoundError: No module named 'dash'</error></testcase><testcase classname="" name="src.tests.unit.frontend.test_dashboard_manager_handlers" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/frontend/test_dashboard_manager_handlers.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/frontend/test_dashboard_manager_handlers.py:16: in &lt;module&gt;
    import dash
E   ModuleNotFoundError: No module named 'dash'</error></testcase><testcase classname="" name="src.tests.unit.frontend.test_dataset_plotter_coverage" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/frontend/test_dataset_plotter_coverage.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/frontend/test_dataset_plotter_coverage.py:23: in &lt;module&gt;
    import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'</error></testcase><testcase classname="" name="src.tests.unit.frontend.test_decision_boundary_callback_coverage" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/frontend/test_decision_boundary_callback_coverage.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/frontend/test_decision_boundary_callback_coverage.py:11: in &lt;module&gt;
    import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'</error></testcase><testcase classname="" name="src.tests.unit.frontend.test_decision_boundary_coverage" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/frontend/test_decision_boundary_coverage.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/frontend/test_decision_boundary_coverage.py:18: in &lt;module&gt;
    import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'</error></testcase><testcase classname="" name="src.tests.unit.frontend.test_hdf5_callbacks" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/frontend/test_hdf5_callbacks.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/frontend/test_hdf5_callbacks.py:30: in &lt;module&gt;
    from dash import html
E   ModuleNotFoundError: No module named 'dash'</error></testcase><testcase classname="" name="src.tests.unit.frontend.test_hdf5_snapshots_panel" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/frontend/test_hdf5_snapshots_panel.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/frontend/test_hdf5_snapshots_panel.py:25: in &lt;module&gt;
    from dash import dcc, html  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^
E   ModuleNotFoundError: No module named 'dash'</error></testcase><testcase classname="" name="src.tests.unit.frontend.test_metrics_panel_coverage" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/frontend/test_metrics_panel_coverage.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/frontend/test_metrics_panel_coverage.py:24: in &lt;module&gt;
    import plotly.graph_objects as go  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   ModuleNotFoundError: No module named 'plotly'</error></testcase><testcase classname="" name="src.tests.unit.frontend.test_metrics_panel_handlers" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/frontend/test_metrics_panel_handlers.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/frontend/test_metrics_panel_handlers.py:25: in &lt;module&gt;
    from frontend.components.metrics_panel import MetricsPanel  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/frontend/components/metrics_panel.py:46: in &lt;module&gt;
    import dash
E   ModuleNotFoundError: No module named 'dash'</error></testcase><testcase classname="" name="src.tests.unit.frontend.test_metrics_panel_helpers_coverage" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/frontend/test_metrics_panel_helpers_coverage.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/frontend/test_metrics_panel_helpers_coverage.py:25: in &lt;module&gt;
    from frontend.components.metrics_panel import MetricsPanel  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/frontend/components/metrics_panel.py:46: in &lt;module&gt;
    import dash
E   ModuleNotFoundError: No module named 'dash'</error></testcase><testcase classname="" name="src.tests.unit.frontend.test_metrics_panel_layouts" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/frontend/test_metrics_panel_layouts.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/frontend/test_metrics_panel_layouts.py:24: in &lt;module&gt;
    from frontend.components.metrics_panel import MetricsPanel  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/frontend/components/metrics_panel.py:46: in &lt;module&gt;
    import dash
E   ModuleNotFoundError: No module named 'dash'</error></testcase><testcase classname="" name="src.tests.unit.frontend.test_network_visualizer_3d" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/frontend/test_network_visualizer_3d.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/frontend/test_network_visualizer_3d.py:24: in &lt;module&gt;
    from frontend.components.network_visualizer import NetworkVisualizer  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/frontend/components/network_visualizer.py:45: in &lt;module&gt;
    import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'</error></testcase><testcase classname="" name="src.tests.unit.frontend.test_network_visualizer_callbacks" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/frontend/test_network_visualizer_callbacks.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/frontend/test_network_visualizer_callbacks.py:31: in &lt;module&gt;
    import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'</error></testcase><testcase classname="" name="src.tests.unit.frontend.test_network_visualizer_coverage" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/frontend/test_network_visualizer_coverage.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/frontend/test_network_visualizer_coverage.py:25: in &lt;module&gt;
    import plotly.graph_objects as go  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   ModuleNotFoundError: No module named 'plotly'</error></testcase><testcase classname="" name="src.tests.unit.frontend.test_network_visualizer_layout_coverage" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/frontend/test_network_visualizer_layout_coverage.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/frontend/test_network_visualizer_layout_coverage.py:26: in &lt;module&gt;
    import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'</error></testcase><testcase classname="" name="src.tests.unit.test_candidate_tracking" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/test_candidate_tracking.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/test_candidate_tracking.py:10: in &lt;module&gt;
    from backend.training_monitor import CandidatePool
src/backend/training_monitor.py:46: in &lt;module&gt;
    from .data_adapter import DataAdapter, NetworkTopology, TrainingMetrics
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
src/backend/statistics.py:37: in &lt;module&gt;
    from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'</error></testcase><testcase classname="" name="src.tests.unit.test_dashboard_manager" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/test_dashboard_manager.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/test_dashboard_manager.py:24: in &lt;module&gt;
    from frontend.dashboard_manager import DashboardManager  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/frontend/dashboard_manager.py:42: in &lt;module&gt;
    import dash
E   ModuleNotFoundError: No module named 'dash'</error></testcase><testcase classname="" name="src.tests.unit.test_dataset_plotter" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/test_dataset_plotter.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/test_dataset_plotter.py:27: in &lt;module&gt;
    from frontend.components.dataset_plotter import DatasetPlotter  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/frontend/components/dataset_plotter.py:40: in &lt;module&gt;
    import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'</error></testcase><testcase classname="" name="src.tests.unit.test_decision_boundary" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/test_decision_boundary.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/test_decision_boundary.py:27: in &lt;module&gt;
    from frontend.components.decision_boundary import DecisionBoundary  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/frontend/components/decision_boundary.py:40: in &lt;module&gt;
    import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'</error></testcase><testcase classname="" name="src.tests.unit.test_main_coverage" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/test_main_coverage.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/test_main_coverage.py:20: in &lt;module&gt;
    from fastapi.testclient import TestClient
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.unit.test_max_epochs_parameter" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/test_max_epochs_parameter.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/test_max_epochs_parameter.py:17: in &lt;module&gt;
    from frontend.dashboard_manager import DashboardManager
src/frontend/dashboard_manager.py:42: in &lt;module&gt;
    import dash
E   ModuleNotFoundError: No module named 'dash'</error></testcase><testcase classname="" name="src.tests.unit.test_message_builders" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/test_message_builders.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/test_message_builders.py:23: in &lt;module&gt;
    from communication.websocket_manager import (
src/communication/websocket_manager.py:143: in &lt;module&gt;
    from fastapi import WebSocket
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.unit.test_metrics_panel" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/test_metrics_panel.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/test_metrics_panel.py:22: in &lt;module&gt;
    import plotly.graph_objects as go  # noqa: E402, F401 - used in assertions
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   ModuleNotFoundError: No module named 'plotly'</error></testcase><testcase classname="" name="src.tests.unit.test_network_info_enhancements" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/test_network_info_enhancements.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/test_network_info_enhancements.py:17: in &lt;module&gt;
    from frontend.dashboard_manager import DashboardManager
src/frontend/dashboard_manager.py:42: in &lt;module&gt;
    import dash
E   ModuleNotFoundError: No module named 'dash'</error></testcase><testcase classname="" name="src.tests.unit.test_network_visualizer" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/test_network_visualizer.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/test_network_visualizer.py:26: in &lt;module&gt;
    from frontend.components.network_visualizer import NetworkVisualizer  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/frontend/components/network_visualizer.py:45: in &lt;module&gt;
    import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'</error></testcase><testcase classname="" name="src.tests.unit.test_plot_rendering" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/test_plot_rendering.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/test_plot_rendering.py:7: in &lt;module&gt;
    from frontend.components.dataset_plotter import DatasetPlotter  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/frontend/components/dataset_plotter.py:40: in &lt;module&gt;
    import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'</error></testcase><testcase classname="" name="src.tests.unit.test_training_metrics" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/test_training_metrics.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/test_training_metrics.py:24: in &lt;module&gt;
    from frontend.components.training_metrics import TrainingMetricsComponent  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/frontend/components/training_metrics.py:35: in &lt;module&gt;
    import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'</error></testcase><testcase classname="" name="src.tests.unit.test_training_state" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/test_training_state.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/test_training_state.py:25: in &lt;module&gt;
    from backend.training_monitor import TrainingState
src/backend/training_monitor.py:46: in &lt;module&gt;
    from .data_adapter import DataAdapter, NetworkTopology, TrainingMetrics
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
src/backend/statistics.py:37: in &lt;module&gt;
    from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'</error></testcase><testcase classname="" name="src.tests.unit.test_websocket_comprehensive" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/test_websocket_comprehensive.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/test_websocket_comprehensive.py:26: in &lt;module&gt;
    from communication.websocket_manager import (
src/communication/websocket_manager.py:143: in &lt;module&gt;
    from fastapi import WebSocket
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.unit.test_websocket_manager_unit" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/test_websocket_manager_unit.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/test_websocket_manager_unit.py:30: in &lt;module&gt;
    from communication.websocket_manager import WebSocketManager  # noqa: E402
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/communication/websocket_manager.py:143: in &lt;module&gt;
    from fastapi import WebSocket
E   ModuleNotFoundError: No module named 'fastapi'</error></testcase><testcase classname="" name="src.tests.unit.test_weight_statistics" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/test_weight_statistics.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/home/pcalnon/.local/lib/python3.14/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
src/tests/unit/test_weight_statistics.py:22: in &lt;module&gt;
    from backend.statistics import compute_weight_statistics
src/backend/statistics.py:37: in &lt;module&gt;
    from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'</error></testcase><testcase classname="src.tests.integration.test_architectural_fixes.TestThreadSafeAsyncBroadcasting" name="test_schedule_broadcast_from_thread" time="0.104" /><testcase classname="src.tests.integration.test_architectural_fixes.TestThreadSafeAsyncBroadcasting" name="test_schedule_broadcast_with_closed_loop" time="0.001" /><testcase classname="src.tests.integration.test_architectural_fixes.TestThreadSafeAsyncBroadcasting" name="test_concurrent_broadcasts_from_multiple_threads" time="0.555" /><testcase classname="src.tests.integration.test_architectural_fixes.TestThreadSafeTopologyExtraction" name="test_topology_extraction_with_lock" time="0.007"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;src.tests.integration.test_architectural_fixes.TestThreadSafeTopologyExtraction object at 0x7b0bd5140a50&gt;
mock_network = &lt;Mock id='135290721935984'&gt;

    def test_topology_extraction_with_lock(self, mock_network):
        """Test that topology extraction uses lock."""
&gt;       from src.backend.cascor_integration import CascorIntegration

src/tests/integration/test_architectural_fixes.py:160:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/cascor_integration.py:61: in &lt;module&gt;
    from .data_adapter import DataAdapter
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.integration.test_architectural_fixes.TestThreadSafeTopologyExtraction" name="test_concurrent_topology_extraction" time="0.003"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;src.tests.integration.test_architectural_fixes.TestThreadSafeTopologyExtraction object at 0x7b0bd5140cd0&gt;
mock_network = &lt;Mock id='135290721939344'&gt;

    def test_concurrent_topology_extraction(self, mock_network):
        """Test that concurrent extractions don't cause errors."""
&gt;       from src.backend.cascor_integration import CascorIntegration

src/tests/integration/test_architectural_fixes.py:180:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/cascor_integration.py:61: in &lt;module&gt;
    from .data_adapter import DataAdapter
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.integration.test_architectural_fixes.TestThreadLifecycle" name="test_stop_monitoring_idempotent" time="0.003"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;src.tests.integration.test_architectural_fixes.TestThreadLifecycle object at 0x7b0bd5140e10&gt;

    def test_stop_monitoring_idempotent(self):
        """Test that stop_monitoring can be called multiple times."""
&gt;       from src.backend.cascor_integration import CascorIntegration

src/tests/integration/test_architectural_fixes.py:223:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/cascor_integration.py:61: in &lt;module&gt;
    from .data_adapter import DataAdapter
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.integration.test_architectural_fixes.TestThreadLifecycle" name="test_stop_monitoring_waits_for_thread" time="0.003"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;src.tests.integration.test_architectural_fixes.TestThreadLifecycle object at 0x7b0bd5140f50&gt;

    def test_stop_monitoring_waits_for_thread(self):
        """Test that stop_monitoring waits for thread to finish."""
&gt;       from src.backend.cascor_integration import CascorIntegration

src/tests/integration/test_architectural_fixes.py:241:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/cascor_integration.py:61: in &lt;module&gt;
    from .data_adapter import DataAdapter
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.integration.test_architectural_fixes.TestThreadLifecycle" name="test_shutdown_idempotent" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;src.tests.integration.test_architectural_fixes.TestThreadLifecycle object at 0x7b0bd51af230&gt;

    def test_shutdown_idempotent(self):
        """Test that shutdown can be called multiple times."""
&gt;       from src.backend.cascor_integration import CascorIntegration

src/tests/integration/test_architectural_fixes.py:267:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/cascor_integration.py:61: in &lt;module&gt;
    from .data_adapter import DataAdapter
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.integration.test_architectural_fixes.TestDashMounting" name="test_dash_uses_requests_pathname_prefix" time="0.003"><failure message="AttributeError: module 'src.frontend' has no attribute 'dashboard_manager'">self = &lt;src.tests.integration.test_architectural_fixes.TestDashMounting object at 0x7b0bd5141590&gt;

    def test_dash_uses_requests_pathname_prefix(self):
        """Test that Dash app uses requests_pathname_prefix instead of url_base_pathname."""
&gt;       with patch("src.frontend.dashboard_manager.dash.Dash") as mock_dash:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/tests/integration/test_architectural_fixes.py:296:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.frontend.dashboard_manager.dash'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.frontend' has no attribute 'dashboard_manager'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.integration.test_architectural_fixes.TestAPIURLDynamicResolution" name="test_callbacks_use_request_host_url" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash'">self = &lt;src.tests.integration.test_architectural_fixes.TestAPIURLDynamicResolution object at 0x7b0bd51416d0&gt;

    def test_callbacks_use_request_host_url(self):
        """Test that callbacks use dynamic request-based URLs instead of hardcoded URLs."""
        import inspect

&gt;       from src.frontend.dashboard_manager import DashboardManager

src/tests/integration/test_architectural_fixes.py:321:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     dashboard_manager.py
    # Author:        Paul Calnon
    # Version:       0.2.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #     Dashboard Manager Module
    #
    #     Central coordination hub for all frontend components, managing layout,
    #     routing, and component lifecycle.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################

    import logging
    import os
    import time
    from typing import Any, Dict, List
    from urllib.parse import urljoin

&gt;   import dash
E   ModuleNotFoundError: No module named 'dash'

src/frontend/dashboard_manager.py:42: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.integration.test_architectural_fixes.TestConfigurationManagement" name="test_config_manager_handles_missing_file" time="0.014" /><testcase classname="src.tests.integration.test_architectural_fixes.TestConfigurationManagement" name="test_environment_variable_overrides" time="0.004" /><testcase classname="src.tests.integration.test_button_state.TestButtonStateIntegration" name="test_button_click_disables_button" time="0.001" /><testcase classname="src.tests.integration.test_button_state.TestButtonStateIntegration" name="test_dashboard_has_button_state_stores" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash'">self = &lt;src.tests.integration.test_button_state.TestButtonStateIntegration object at 0x7b0bd5141a90&gt;

    def test_dashboard_has_button_state_stores(self):
        """Test: Dashboard has button state management stores."""
&gt;       from frontend.dashboard_manager import DashboardManager

src/tests/integration/test_button_state.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     dashboard_manager.py
    # Author:        Paul Calnon
    # Version:       0.2.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #     Dashboard Manager Module
    #
    #     Central coordination hub for all frontend components, managing layout,
    #     routing, and component lifecycle.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################

    import logging
    import os
    import time
    from typing import Any, Dict, List
    from urllib.parse import urljoin

&gt;   import dash
E   ModuleNotFoundError: No module named 'dash'

src/frontend/dashboard_manager.py:42: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.integration.test_button_state.TestButtonStateIntegration" name="test_button_click_sends_single_command" time="0.003"><failure message="ModuleNotFoundError: No module named 'dash'">self = &lt;src.tests.integration.test_button_state.TestButtonStateIntegration object at 0x7b0bd51af5c0&gt;

    def test_button_click_sends_single_command(self):
        """Test: Click Start  verify single command sent."""
        from unittest.mock import MagicMock

&gt;       from frontend.dashboard_manager import DashboardManager

src/tests/integration/test_button_state.py:57:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     dashboard_manager.py
    # Author:        Paul Calnon
    # Version:       0.2.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #     Dashboard Manager Module
    #
    #     Central coordination hub for all frontend components, managing layout,
    #     routing, and component lifecycle.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################

    import logging
    import os
    import time
    from typing import Any, Dict, List
    from urllib.parse import urljoin

&gt;   import dash
E   ModuleNotFoundError: No module named 'dash'

src/frontend/dashboard_manager.py:42: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.integration.test_button_state.TestButtonStateIntegration" name="test_button_re_enables_after_acknowledgment" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash'">self = &lt;src.tests.integration.test_button_state.TestButtonStateIntegration object at 0x7b0bd51af360&gt;

    def test_button_re_enables_after_acknowledgment(self):
        """Test: Click  disable  ack received  button re-enabled."""
        from unittest.mock import MagicMock

&gt;       from frontend.dashboard_manager import DashboardManager

src/tests/integration/test_button_state.py:104:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     dashboard_manager.py
    # Author:        Paul Calnon
    # Version:       0.2.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #     Dashboard Manager Module
    #
    #     Central coordination hub for all frontend components, managing layout,
    #     routing, and component lifecycle.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################

    import logging
    import os
    import time
    from typing import Any, Dict, List
    from urllib.parse import urljoin

&gt;   import dash
E   ModuleNotFoundError: No module named 'dash'

src/frontend/dashboard_manager.py:42: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.integration.test_button_state.TestButtonStateIntegration" name="test_rapid_clicks_only_send_one_command" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash'">self = &lt;src.tests.integration.test_button_state.TestButtonStateIntegration object at 0x7b0bd51fe9f0&gt;

    def test_rapid_clicks_only_send_one_command(self):
        """Test: Rapid clicks  verify only one command sent."""
        from unittest.mock import MagicMock

&gt;       from frontend.dashboard_manager import DashboardManager

src/tests/integration/test_button_state.py:168:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     dashboard_manager.py
    # Author:        Paul Calnon
    # Version:       0.2.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #     Dashboard Manager Module
    #
    #     Central coordination hub for all frontend components, managing layout,
    #     routing, and component lifecycle.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################

    import logging
    import os
    import time
    from typing import Any, Dict, List
    from urllib.parse import urljoin

&gt;   import dash
E   ModuleNotFoundError: No module named 'dash'

src/frontend/dashboard_manager.py:42: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.integration.test_button_state.TestButtonStateIntegration" name="test_loading_indicator_visible" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash'">self = &lt;src.tests.integration.test_button_state.TestButtonStateIntegration object at 0x7b0bd51797b0&gt;

    def test_loading_indicator_visible(self):
        """Test: Button shows loading indicator when clicked."""
        from unittest.mock import MagicMock

&gt;       from frontend.dashboard_manager import DashboardManager

src/tests/integration/test_button_state.py:224:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     dashboard_manager.py
    # Author:        Paul Calnon
    # Version:       0.2.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #     Dashboard Manager Module
    #
    #     Central coordination hub for all frontend components, managing layout,
    #     routing, and component lifecycle.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################

    import logging
    import os
    import time
    from typing import Any, Dict, List
    from urllib.parse import urljoin

&gt;   import dash
E   ModuleNotFoundError: No module named 'dash'

src/frontend/dashboard_manager.py:42: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.integration.test_button_state.TestButtonStateIntegration" name="test_error_handling_re_enables_button" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash'">self = &lt;src.tests.integration.test_button_state.TestButtonStateIntegration object at 0x7b0bd5179e10&gt;

    def test_error_handling_re_enables_button(self):
        """Test: API error  button re-enabled immediately."""
&gt;       from frontend.dashboard_manager import DashboardManager

src/tests/integration/test_button_state.py:269:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     dashboard_manager.py
    # Author:        Paul Calnon
    # Version:       0.2.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #     Dashboard Manager Module
    #
    #     Central coordination hub for all frontend components, managing layout,
    #     routing, and component lifecycle.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################

    import logging
    import os
    import time
    from typing import Any, Dict, List
    from urllib.parse import urljoin

&gt;   import dash
E   ModuleNotFoundError: No module named 'dash'

src/frontend/dashboard_manager.py:42: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.integration.test_config_dashboard_integration.TestConfigDashboardIntegration" name="test_config_defaults_within_bounds" time="0.023" /><testcase classname="src.tests.integration.test_config_dashboard_integration.TestConfigDashboardIntegration" name="test_config_ranges_compatible_with_constants" time="0.028" /><testcase classname="src.tests.integration.test_config_dashboard_integration.TestConfigDashboardIntegration" name="test_config_consistency_check_runs" time="0.028" /><testcase classname="src.tests.integration.test_config_dashboard_integration.TestConfigDashboardIntegration" name="test_param_validation_integration" time="0.024" /><testcase classname="src.tests.integration.test_config_integration.TestEndToEndConfigFlow" name="test_config_manager_initialization" time="0.022" /><testcase classname="src.tests.integration.test_config_integration.TestEndToEndConfigFlow" name="test_config_validation" time="0.021" /><testcase classname="src.tests.integration.test_config_integration.TestEndToEndConfigFlow" name="test_training_defaults_availability" time="0.020" /><testcase classname="src.tests.integration.test_config_integration.TestEndToEndConfigFlow" name="test_config_sections_exist" time="0.020" /><testcase classname="src.tests.integration.test_config_integration.TestDashboardIntegration" name="test_dashboard_config_loading" time="0.020" /><testcase classname="src.tests.integration.test_config_integration.TestDashboardIntegration" name="test_dashboard_env_override" time="0.006" /><testcase classname="src.tests.integration.test_config_integration.TestMetricsPanelIntegration" name="test_metrics_panel_config_access" time="0.023" /><testcase classname="src.tests.integration.test_config_integration.TestMetricsPanelIntegration" name="test_metrics_panel_env_override" time="0.006" /><testcase classname="src.tests.integration.test_config_integration.TestBackendIntegration" name="test_backend_path_resolution" time="0.024" /><testcase classname="src.tests.integration.test_config_integration.TestBackendIntegration" name="test_backend_env_override" time="0.005" /><testcase classname="src.tests.integration.test_config_integration.TestWebSocketIntegration" name="test_websocket_config_loading" time="0.020" /><testcase classname="src.tests.integration.test_config_integration.TestWebSocketIntegration" name="test_websocket_env_override" time="0.005" /><testcase classname="src.tests.integration.test_config_integration.TestDemoModeIntegration" name="test_demo_config_loading" time="0.020" /><testcase classname="src.tests.integration.test_config_integration.TestDemoModeIntegration" name="test_demo_env_override" time="0.005" /><testcase classname="src.tests.integration.test_config_integration.TestMultiComponentConfiguration" name="test_multiple_env_vars_together" time="0.005" /><testcase classname="src.tests.integration.test_config_integration.TestMultiComponentConfiguration" name="test_config_manager_singleton_behavior" time="0.038" /><testcase classname="src.tests.integration.test_config_integration.TestConfigurationPersistence" name="test_config_reload" time="0.037" /><testcase classname="src.tests.integration.test_config_integration.TestConfigurationPersistence" name="test_config_get_method" time="0.020" /><testcase classname="src.tests.integration.test_config_integration.TestErrorHandling" name="test_invalid_env_var_types" time="0.005" /><testcase classname="src.tests.integration.test_config_integration.TestErrorHandling" name="test_missing_config_sections" time="0.023" /><testcase classname="src.tests.integration.test_config_integration.TestErrorHandling" name="test_config_validation_with_errors" time="0.024" /><testcase classname="src.tests.integration.test_config_integration.TestConfigurationSources" name="test_source_determination_env" time="0.005" /><testcase classname="src.tests.integration.test_config_integration.TestConfigurationSources" name="test_source_determination_config" time="0.023" /><testcase classname="src.tests.integration.test_config_integration.TestConfigurationSources" name="test_source_determination_constant" time="0.007" /><testcase classname="src.tests.integration.test_control_transitions.TestDemoModeControlTransitions" name="test_start_to_pause_in_output_to_resume" time="0.281" /><testcase classname="src.tests.integration.test_control_transitions.TestDemoModeControlTransitions" name="test_start_to_pause_in_candidate_to_resume" time="0.253"><failure message="AssertionError">self = &lt;src.tests.integration.test_control_transitions.TestDemoModeControlTransitions object at 0x7b0bd4f34050&gt;
demo_mode = &lt;demo_mode.DemoMode object at 0x7b0bd3526210&gt;

    def test_start_to_pause_in_candidate_to_resume(self, demo_mode):
        """Test: Start  Pause in Candidate  Resume  verify continues in Candidate."""
        # Start training
        demo_mode.start(reset=True)
        assert demo_mode.state_machine.is_started()

        # Wait and force Candidate phase
        time.sleep(0.2)
        demo_mode.state_machine.set_phase(TrainingPhase.CANDIDATE)

        # Save some candidate state
        candidate_state = {"epoch": 10, "loss": 0.5}
        demo_mode.state_machine.save_candidate_state(candidate_state)

        # Pause
        demo_mode.pause()
        assert demo_mode.state_machine.is_paused()
        assert demo_mode.state_machine.get_paused_phase() == TrainingPhase.CANDIDATE

        # Resume
        demo_mode.resume()
        assert demo_mode.state_machine.is_started()
&gt;       assert demo_mode.state_machine.get_phase() == TrainingPhase.CANDIDATE
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError

src/tests/integration/test_control_transitions.py:72: AssertionError</failure></testcase><testcase classname="src.tests.integration.test_control_transitions.TestDemoModeControlTransitions" name="test_start_to_pause_to_start_acts_as_resume" time="0.338" /><testcase classname="src.tests.integration.test_control_transitions.TestDemoModeControlTransitions" name="test_start_to_stop_truly_stops" time="0.549" /><testcase classname="src.tests.integration.test_control_transitions.TestDemoModeControlTransitions" name="test_invalid_transitions_rejected" time="0.148" /><testcase classname="src.tests.integration.test_control_transitions.TestDemoModeControlTransitions" name="test_reset_clears_all_state" time="0.345" /><testcase classname="src.tests.integration.test_control_transitions.TestDemoModeControlTransitions" name="test_rapid_start_pause_resume_stop" time="0.280" /><testcase classname="src.tests.integration.test_control_transitions.TestDemoModeControlTransitions" name="test_pause_resume_preserves_training_progress" time="0.851" /><testcase classname="src.tests.integration.test_control_transitions.TestDemoModeControlTransitions" name="test_candidate_phase_state_persists_across_pause_resume" time="0.255" /><testcase classname="src.tests.integration.test_control_transitions.TestStateConsistency" name="test_fsm_and_demo_state_consistency" time="0.028" /><testcase classname="src.tests.integration.test_control_transitions.TestStateConsistency" name="test_training_state_reflects_fsm_state" time="0.029"><skipped type="pytest.skip" message="TrainingState not available">/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/integration/test_control_transitions.py:290: TrainingState not available</skipped></testcase><testcase classname="src.tests.integration.test_control_transitions.TestEdgeCases" name="test_double_start_idempotent" time="0.027" /><testcase classname="src.tests.integration.test_control_transitions.TestEdgeCases" name="test_double_stop_idempotent" time="0.023" /><testcase classname="src.tests.integration.test_control_transitions.TestEdgeCases" name="test_phase_transitions_during_training" time="1.022" /><testcase classname="src.tests.integration.test_css_interference" name="test_dark_mode_css_no_global_selector" time="0.001" /><testcase classname="src.tests.integration.test_css_interference" name="test_plotly_fix_css_exists" time="0.001" /><testcase classname="src.tests.integration.test_css_interference" name="test_plotly_fix_css_has_svg_protection" time="0.001" /><testcase classname="src.tests.integration.test_mvp" name="test_api_health" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture
    def client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/integration/test_mvp.py:26: ModuleNotFoundError</error></testcase><testcase classname="src.tests.integration.test_mvp" name="test_api_status" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture
    def client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/integration/test_mvp.py:26: ModuleNotFoundError</error></testcase><testcase classname="src.tests.integration.test_mvp" name="test_api_dataset" time="0.001"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture
    def client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/integration/test_mvp.py:26: ModuleNotFoundError</error></testcase><testcase classname="src.tests.integration.test_mvp" name="test_root_redirect" time="0.001"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture
    def client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/integration/test_mvp.py:26: ModuleNotFoundError</error></testcase><testcase classname="src.tests.integration.test_mvp" name="test_dashboard_accessible" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture
    def client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/integration/test_mvp.py:26: ModuleNotFoundError</error></testcase><testcase classname="src.tests.integration.test_setup" name="test_imports" time="0.002"><failure message="AssertionError: Failed to import dash: No module named 'dash'">def test_imports():
        """Test that all required packages can be imported."""
        print("Testing package imports...")
        # Core required packages
        required_packages = ["dash", "fastapi", "plotly", "torch", "numpy", "yaml", "colorama", "psutil"]
        # Optional packages (not always installed)
        optional_packages = ["redis", "pandas"]

        for package in required_packages:  # sourcery skip: no-loop-in-tests
            try:
&gt;               __import__(package)
E               ModuleNotFoundError: No module named 'dash'

src/tests/integration/test_setup.py:20: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    def test_imports():
        """Test that all required packages can be imported."""
        print("Testing package imports...")
        # Core required packages
        required_packages = ["dash", "fastapi", "plotly", "torch", "numpy", "yaml", "colorama", "psutil"]
        # Optional packages (not always installed)
        optional_packages = ["redis", "pandas"]

        for package in required_packages:  # sourcery skip: no-loop-in-tests
            try:
                __import__(package)
                print(f"   {package}")
            except ImportError as e:
                print(f"   {package}: {e}")
&gt;               raise AssertionError(f"Failed to import {package}: {e}") from e
E               AssertionError: Failed to import dash: No module named 'dash'

src/tests/integration/test_setup.py:24: AssertionError</failure></testcase><testcase classname="src.tests.integration.test_setup" name="test_logging" time="0.021" /><testcase classname="src.tests.integration.test_setup" name="test_directories" time="0.001" /><testcase classname="src.tests.integration.test_websocket_control.TestWebSocketControlIntegration" name="test_control_websocket_connection" time="0.003"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'uvicorn'&quot;">self = &lt;src.tests.integration.test_websocket_control.TestWebSocketControlIntegration object at 0x7b0bd52d82d0&gt;

    @pytest.fixture
    def demo_app(self):
        """Create FastAPI app with demo mode for testing."""
        import os
        import sys
        from pathlib import Path

        # MUST set environment variable BEFORE importing main
        os.environ["CASCOR_DEMO_MODE"] = "1"  # Force demo mode

        # Add src to path
        src_path = Path(__file__).parent.parent.parent
        if str(src_path) not in sys.path:
            sys.path.insert(0, str(src_path))

        # Import and return app (demo_mode_active will be True)
&gt;       from main import app

src/tests/integration/test_websocket_control.py:32:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</error></testcase><testcase classname="src.tests.integration.test_websocket_control.TestWebSocketControlIntegration" name="test_control_start_command" time="0.003"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'uvicorn'&quot;">self = &lt;src.tests.integration.test_websocket_control.TestWebSocketControlIntegration object at 0x7b0bd52d8690&gt;

    @pytest.fixture
    def demo_app(self):
        """Create FastAPI app with demo mode for testing."""
        import os
        import sys
        from pathlib import Path

        # MUST set environment variable BEFORE importing main
        os.environ["CASCOR_DEMO_MODE"] = "1"  # Force demo mode

        # Add src to path
        src_path = Path(__file__).parent.parent.parent
        if str(src_path) not in sys.path:
            sys.path.insert(0, str(src_path))

        # Import and return app (demo_mode_active will be True)
&gt;       from main import app

src/tests/integration/test_websocket_control.py:32:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</error></testcase><testcase classname="src.tests.integration.test_websocket_control.TestWebSocketControlIntegration" name="test_control_pause_resume" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'uvicorn'&quot;">self = &lt;src.tests.integration.test_websocket_control.TestWebSocketControlIntegration object at 0x7b0bd52110f0&gt;

    @pytest.fixture
    def demo_app(self):
        """Create FastAPI app with demo mode for testing."""
        import os
        import sys
        from pathlib import Path

        # MUST set environment variable BEFORE importing main
        os.environ["CASCOR_DEMO_MODE"] = "1"  # Force demo mode

        # Add src to path
        src_path = Path(__file__).parent.parent.parent
        if str(src_path) not in sys.path:
            sys.path.insert(0, str(src_path))

        # Import and return app (demo_mode_active will be True)
&gt;       from main import app

src/tests/integration/test_websocket_control.py:32:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</error></testcase><testcase classname="src.tests.integration.test_websocket_control.TestWebSocketControlIntegration" name="test_control_stop_command" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'uvicorn'&quot;">self = &lt;src.tests.integration.test_websocket_control.TestWebSocketControlIntegration object at 0x7b0bd5211220&gt;

    @pytest.fixture
    def demo_app(self):
        """Create FastAPI app with demo mode for testing."""
        import os
        import sys
        from pathlib import Path

        # MUST set environment variable BEFORE importing main
        os.environ["CASCOR_DEMO_MODE"] = "1"  # Force demo mode

        # Add src to path
        src_path = Path(__file__).parent.parent.parent
        if str(src_path) not in sys.path:
            sys.path.insert(0, str(src_path))

        # Import and return app (demo_mode_active will be True)
&gt;       from main import app

src/tests/integration/test_websocket_control.py:32:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</error></testcase><testcase classname="src.tests.integration.test_websocket_control.TestWebSocketControlIntegration" name="test_control_reset_command" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'uvicorn'&quot;">self = &lt;src.tests.integration.test_websocket_control.TestWebSocketControlIntegration object at 0x7b0bd4ccc4d0&gt;

    @pytest.fixture
    def demo_app(self):
        """Create FastAPI app with demo mode for testing."""
        import os
        import sys
        from pathlib import Path

        # MUST set environment variable BEFORE importing main
        os.environ["CASCOR_DEMO_MODE"] = "1"  # Force demo mode

        # Add src to path
        src_path = Path(__file__).parent.parent.parent
        if str(src_path) not in sys.path:
            sys.path.insert(0, str(src_path))

        # Import and return app (demo_mode_active will be True)
&gt;       from main import app

src/tests/integration/test_websocket_control.py:32:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</error></testcase><testcase classname="src.tests.integration.test_websocket_control.TestWebSocketControlIntegration" name="test_control_unknown_command" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'uvicorn'&quot;">self = &lt;src.tests.integration.test_websocket_control.TestWebSocketControlIntegration object at 0x7b0bd4ff68b0&gt;

    @pytest.fixture
    def demo_app(self):
        """Create FastAPI app with demo mode for testing."""
        import os
        import sys
        from pathlib import Path

        # MUST set environment variable BEFORE importing main
        os.environ["CASCOR_DEMO_MODE"] = "1"  # Force demo mode

        # Add src to path
        src_path = Path(__file__).parent.parent.parent
        if str(src_path) not in sys.path:
            sys.path.insert(0, str(src_path))

        # Import and return app (demo_mode_active will be True)
&gt;       from main import app

src/tests/integration/test_websocket_control.py:32:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</error></testcase><testcase classname="src.tests.integration.test_websocket_control.TestWebSocketTrainingIntegration" name="test_training_websocket_connection" time="0.003"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'uvicorn'&quot;">self = &lt;src.tests.integration.test_websocket_control.TestWebSocketTrainingIntegration object at 0x7b0bd52d8910&gt;

    @pytest.fixture
    def demo_app(self):
        """Create FastAPI app with demo mode for testing."""
        import os
        import sys
        from pathlib import Path

        # MUST set environment variable BEFORE importing main
        os.environ["CASCOR_DEMO_MODE"] = "1"

        src_path = Path(__file__).parent.parent.parent
        if str(src_path) not in sys.path:
            sys.path.insert(0, str(src_path))

&gt;       from main import app

src/tests/integration/test_websocket_control.py:197:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</error></testcase><testcase classname="src.tests.integration.test_websocket_control.TestWebSocketTrainingIntegration" name="test_training_metrics_broadcast" time="0.004"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'uvicorn'&quot;">self = &lt;src.tests.integration.test_websocket_control.TestWebSocketTrainingIntegration object at 0x7b0bd52d8a50&gt;

    @pytest.fixture
    def demo_app(self):
        """Create FastAPI app with demo mode for testing."""
        import os
        import sys
        from pathlib import Path

        # MUST set environment variable BEFORE importing main
        os.environ["CASCOR_DEMO_MODE"] = "1"

        src_path = Path(__file__).parent.parent.parent
        if str(src_path) not in sys.path:
            sys.path.insert(0, str(src_path))

&gt;       from main import app

src/tests/integration/test_websocket_control.py:197:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</error></testcase><testcase classname="src.tests.integration.test_websocket_control.TestEndToEndFlow" name="test_complete_training_lifecycle" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'uvicorn'&quot;">self = &lt;src.tests.integration.test_websocket_control.TestEndToEndFlow object at 0x7b0bd52d8cd0&gt;

    @pytest.fixture
    def demo_app(self):
        """Create FastAPI app with demo mode for testing."""
        import os
        import sys
        from pathlib import Path

        # MUST set environment variable BEFORE importing main
        os.environ["CASCOR_DEMO_MODE"] = "1"

        src_path = Path(__file__).parent.parent.parent
        if str(src_path) not in sys.path:
            sys.path.insert(0, str(src_path))

&gt;       from main import app

src/tests/integration/test_websocket_control.py:280:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</error></testcase><testcase classname="src.tests.integration.test_websocket_control.TestEndToEndFlow" name="test_api_endpoints_during_training" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'uvicorn'&quot;">self = &lt;src.tests.integration.test_websocket_control.TestEndToEndFlow object at 0x7b0bd52d8e10&gt;

    @pytest.fixture
    def demo_app(self):
        """Create FastAPI app with demo mode for testing."""
        import os
        import sys
        from pathlib import Path

        # MUST set environment variable BEFORE importing main
        os.environ["CASCOR_DEMO_MODE"] = "1"

        src_path = Path(__file__).parent.parent.parent
        if str(src_path) not in sys.path:
            sys.path.insert(0, str(src_path))

&gt;       from main import app

src/tests/integration/test_websocket_control.py:280:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</error></testcase><testcase classname="src.tests.performance.test_button_responsiveness.TestButtonResponsiveness" name="test_button_visual_feedback_latency" time="0.003"><failure message="ModuleNotFoundError: No module named 'dash'">self = &lt;test_button_responsiveness.TestButtonResponsiveness object at 0x7b0bd52d9590&gt;

    def test_button_visual_feedback_latency(self):
        """Test that visual feedback occurs within 100ms of click."""
&gt;       from frontend.dashboard_manager import DashboardManager

src/tests/performance/test_button_responsiveness.py:33:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     dashboard_manager.py
    # Author:        Paul Calnon
    # Version:       0.2.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #     Dashboard Manager Module
    #
    #     Central coordination hub for all frontend components, managing layout,
    #     routing, and component lifecycle.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################

    import logging
    import os
    import time
    from typing import Any, Dict, List
    from urllib.parse import urljoin

&gt;   import dash
E   ModuleNotFoundError: No module named 'dash'

src/frontend/dashboard_manager.py:42: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.performance.test_button_responsiveness.TestButtonResponsiveness" name="test_rapid_clicking_prevention" time="0.001" /><testcase classname="src.tests.performance.test_button_responsiveness.TestButtonResponsiveness" name="test_button_disable_during_execution" time="0.001" /><testcase classname="src.tests.performance.test_button_responsiveness.TestButtonResponsiveness" name="test_button_re_enable_after_timeout" time="0.001" /><testcase classname="src.tests.performance.test_button_responsiveness.TestButtonResponsiveness" name="test_button_re_enable_after_success" time="0.001" /><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestBackendImportErrors" name="test_import_backend_modules_cascadecorrelation_import_error" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestBackendImportErrors object at 0x7b0bd52da710&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestBackendImportErrors" name="test_add_backend_to_path_missing_src" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestBackendImportErrors object at 0x7b0bd52da990&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestMonitoredMethodWrappers" name="test_monitored_fit_calls_callbacks" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestMonitoredMethodWrappers object at 0x7b0bd52daad0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestMonitoredMethodWrappers" name="test_monitored_train_output_layer_calls_callbacks" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestMonitoredMethodWrappers object at 0x7b0bd52dac10&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestMonitoredMethodWrappers" name="test_monitored_train_candidates_calls_callbacks" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestMonitoredMethodWrappers object at 0x7b0bd52135c0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestMonitoredMethodWrappers" name="test_install_hooks_exception_handling" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestMonitoredMethodWrappers object at 0x7b0bd5212780&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestTrainingLifecycleCallbacks" name="test_on_training_start_broadcasts_message" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestTrainingLifecycleCallbacks object at 0x7b0bd52db110&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestTrainingLifecycleCallbacks" name="test_on_training_complete_broadcasts_message" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestTrainingLifecycleCallbacks object at 0x7b0bd52db250&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestMonitoringLoop" name="test_extract_current_metrics_with_history" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestMonitoringLoop object at 0x7b0bd52db390&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestMonitoringLoop" name="test_extract_current_metrics_no_network" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestMonitoringLoop object at 0x7b0bd52db4d0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestMonitoringLoop" name="test_extract_current_metrics_no_history_attribute" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestMonitoringLoop object at 0x7b0bd5213820&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestMonitoringLoop" name="test_extract_current_metrics_empty_history" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestMonitoringLoop object at 0x7b0bd52136f0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestMonitoringLoop" name="test_monitoring_loop_broadcasts_metrics" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestMonitoringLoop object at 0x7b0bd4cccdd0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestMonitoringLoop" name="test_monitoring_loop_handles_exception" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestMonitoringLoop object at 0x7b0bd4c4c270&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestMonitoringLoop" name="test_start_monitoring_thread_already_running" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestMonitoringLoop object at 0x7b0bd4c4c160&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestMonitoringLoop" name="test_stop_monitoring_not_active" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestMonitoringLoop object at 0x7b0bd4c1c950&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestTopologyExtractionWithHiddenUnits" name="test_get_network_topology_with_hidden_units" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestTopologyExtractionWithHiddenUnits object at 0x7b0bd52db610&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestTopologyExtractionWithHiddenUnits" name="test_get_network_topology_exception_handling" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestTopologyExtractionWithHiddenUnits object at 0x7b0bd52db750&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestCascorTopologyExtraction" name="test_extract_cascor_topology_no_instance" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestCascorTopologyExtraction object at 0x7b0bd52db890&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestCascorTopologyExtraction" name="test_extract_cascor_topology_with_instance" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestCascorTopologyExtraction object at 0x7b0bd52db9d0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestCascorTopologyExtraction" name="test_cascor_topology_get_components_no_instance" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestCascorTopologyExtraction object at 0x7b0bd5213950&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestCascorTopologyExtraction" name="test_extract_cascor_topology_exception" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestCascorTopologyExtraction object at 0x7b0bd5213a80&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestDatasetInfoFromNetwork" name="test_get_dataset_info_from_network_attributes" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestDatasetInfoFromNetwork object at 0x7b0bd52dbb10&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestDatasetInfoFromNetwork" name="test_get_dataset_info_with_numpy_arrays" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestDatasetInfoFromNetwork object at 0x7b0bd52dbc50&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestDatasetInfoFromNetwork" name="test_get_dataset_info_exception_handling" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestDatasetInfoFromNetwork object at 0x7b0bd5213bb0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestTrainingStatus" name="test_get_training_status_with_network" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestTrainingStatus object at 0x7b0bd52dbd90&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestTrainingStatus" name="test_get_training_status_without_network" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestTrainingStatus object at 0x7b0bd52dbed0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestPredictionFunctionWithTorch" name="test_prediction_function_with_torch_tensor" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestPredictionFunctionWithTorch object at 0x7b0bd4cd4050&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestCallbackRegistration" name="test_create_monitoring_callback" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestCallbackRegistration object at 0x7b0bd4cd4190&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestPathResolutionEdgeCases" name="test_resolve_path_from_yaml_config" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestPathResolutionEdgeCases object at 0x7b0bd4cd42d0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestPathResolutionEdgeCases" name="test_resolve_path_with_braced_env_var" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestPathResolutionEdgeCases object at 0x7b0bd4cd4410&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestOriginalMethodProperties" name="test_original_train_output_property" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestOriginalMethodProperties object at 0x7b0bd4cd4550&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestOriginalMethodProperties" name="test_original_train_candidates_property" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestOriginalMethodProperties object at 0x7b0bd4cd4690&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestOriginalMethodProperties" name="test_original_properties_before_hooks_installed" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestOriginalMethodProperties object at 0x7b0bd5213ce0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestShutdownEdgeCases" name="test_shutdown_with_active_monitoring" time="0.004"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestShutdownEdgeCases object at 0x7b0bd4cd47d0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestShutdownEdgeCases" name="test_restore_original_methods_no_network" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestShutdownEdgeCases object at 0x7b0bd4cd4910&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestShutdownEdgeCases" name="test_destructor_calls_shutdown" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestShutdownEdgeCases object at 0x7b0bd5213e10&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestExtractNetworkTopologyAlias" name="test_extract_network_topology_is_alias" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestExtractNetworkTopologyAlias object at 0x7b0bd4cd4a50&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestStopMonitoringThreadTimeout" name="test_stop_monitoring_thread_timeout_warning" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestStopMonitoringThreadTimeout object at 0x7b0bd4cd4b90&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestPhaseCallbacks" name="test_on_output_phase_start" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestPhaseCallbacks object at 0x7b0bd4cd4cd0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestPhaseCallbacks" name="test_on_output_phase_end" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestPhaseCallbacks object at 0x7b0bd4cd4e10&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestPhaseCallbacks" name="test_on_candidate_phase_start" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestPhaseCallbacks object at 0x7b0bd4ca4050&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestPhaseCallbacks" name="test_on_candidate_phase_end_with_dict" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestPhaseCallbacks object at 0x7b0bd4ca4180&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestPhaseCallbacks" name="test_on_candidate_phase_end_with_tuple" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestPhaseCallbacks object at 0x7b0bd4ccccb0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestSerializeHistory" name="test_serialize_history_with_tensors" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestSerializeHistory object at 0x7b0bd4cd4f50&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestBroadcastMessage" name="test_broadcast_message_success" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestBroadcastMessage object at 0x7b0bd4cd5090&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestBroadcastMessage" name="test_broadcast_message_handles_exception" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestBroadcastMessage object at 0x7b0bd4cd51d0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestCreateNetworkNoneConfig" name="test_create_network_with_none_config" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestCreateNetworkNoneConfig object at 0x7b0bd4cd5310&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_comprehensive.TestOutputPhaseEndEmptyAccuracy" name="test_on_output_phase_end_no_accuracy" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_comprehensive.TestOutputPhaseEndEmptyAccuracy object at 0x7b0bd4cd5450&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationInit" name="test_init_with_default_path" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationInit object at 0x7b0bd4cd5590&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationInit" name="test_init_with_explicit_path" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationInit object at 0x7b0bd4cd56d0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationInit" name="test_init_with_missing_backend_raises_error" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationInit object at 0x7b0bd4ca42b0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationInit" name="test_init_with_environment_variable_path" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationInit object at 0x7b0bd4ca43e0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationPathResolution" name="test_resolve_backend_path_tilde_expansion" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationPathResolution object at 0x7b0bd4cd5810&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationPathResolution" name="test_resolve_backend_path_env_var_expansion" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationPathResolution object at 0x7b0bd4cd5950&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationNetworkCreation" name="test_create_network_with_minimal_config" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationNetworkCreation object at 0x7b0bd4cd5a90&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationNetworkCreation" name="test_create_network_with_max_epochs_mapping" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationNetworkCreation object at 0x7b0bd4cd5bd0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationNetworkCreation" name="test_connect_to_network" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationNetworkCreation object at 0x7b0bd4ca4510&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationMonitoringHooks" name="test_install_monitoring_hooks_without_network" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationMonitoringHooks object at 0x7b0bd4cd5d10&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationMonitoringHooks" name="test_install_monitoring_hooks_with_network" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationMonitoringHooks object at 0x7b0bd4cd5e50&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationMonitoringHooks" name="test_install_monitoring_hooks_twice" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationMonitoringHooks object at 0x7b0bd4ca4640&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationTopologyExtraction" name="test_get_network_topology_without_network" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationTopologyExtraction object at 0x7b0bd4cd5f90&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationTopologyExtraction" name="test_get_network_topology_with_network" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationTopologyExtraction object at 0x7b0bd4cd60d0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationDatasetInfo" name="test_get_dataset_info_with_tensors" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationDatasetInfo object at 0x7b0bd4cd6210&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationDatasetInfo" name="test_get_dataset_info_without_data_generates_mock" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationDatasetInfo object at 0x7b0bd4cd6350&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationPredictionFunction" name="test_get_prediction_function_without_network" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationPredictionFunction object at 0x7b0bd4cd6490&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationPredictionFunction" name="test_get_prediction_function_with_network" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationPredictionFunction object at 0x7b0bd4cd65d0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationMonitoringThread" name="test_start_monitoring_thread" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationMonitoringThread object at 0x7b0bd4cd6710&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationMonitoringThread" name="test_stop_monitoring" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationMonitoringThread object at 0x7b0bd4cd6850&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationCleanup" name="test_shutdown" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationCleanup object at 0x7b0bd4cd6990&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationCleanup" name="test_restore_original_methods" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationCleanup object at 0x7b0bd4cd6ad0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationPropertyAliases" name="test_original_fit_property" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationPropertyAliases object at 0x7b0bd4cd6c10&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cascor_integration_coverage.TestCascorIntegrationPropertyAliases" name="test_connect_to_cascor_network_alias" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">args = (&lt;test_cascor_integration_coverage.TestCascorIntegrationPropertyAliases object at 0x7b0bd4cd6d50&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1429:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientDisabled" name="test_disabled_by_config_returns_disabled_status" time="0.033" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientDisabled" name="test_disabled_status_details_contains_config_info" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientDisabled" name="test_disabled_metrics_returns_empty_metrics" time="0.002" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientDriverMissing" name="test_driver_missing_returns_unavailable_status" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientDriverMissing" name="test_driver_missing_metrics_returns_unavailable" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientDemoMode" name="test_demo_mode_returns_up_status" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientDemoMode" name="test_demo_mode_returns_synthetic_cluster_data" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientDemoMode" name="test_demo_mode_hosts_have_required_fields" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientDemoMode" name="test_demo_mode_metrics_returns_synthetic_data" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientDemoMode" name="test_demo_mode_keyspaces_have_tables" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientDemoMode" name="test_demo_mode_cluster_stats" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientConnectionFailure" name="test_connection_failure_returns_unavailable" time="0.004" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientConnectionFailure" name="test_try_connect_returns_false_on_exception" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientStatusStructure" name="test_status_has_required_fields" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientStatusStructure" name="test_status_cached_within_ttl" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientMetricsStructure" name="test_metrics_has_required_fields" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientClose" name="test_close_cleans_up_resources" time="0.002" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientClose" name="test_close_handles_shutdown_exception" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientSingleton" name="test_get_cassandra_client_returns_same_instance" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientSingleton" name="test_get_cassandra_client_creates_instance_with_config" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientLiveStatus" name="test_live_status_extracts_host_info" time="0.005" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientIsConnected" name="test_is_connected_returns_false_when_no_session" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientIsConnected" name="test_is_connected_returns_true_when_session_active" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientIsConnected" name="test_is_connected_returns_false_when_session_shutdown" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientIsConnected" name="test_is_connected_returns_false_on_exception" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientTryConnectWithAuth" name="test_try_connect_with_auth_provider" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientTryConnectWithAuth" name="test_try_connect_sets_keyspace" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientTryConnectWithAuth" name="test_try_connect_returns_false_when_driver_unavailable" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientGetStatusRetryConnect" name="test_get_status_retries_connect_when_not_connected" time="0.002" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientGetLiveStatusException" name="test_get_live_status_returns_down_on_exception" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientGetLiveStatusException" name="test_get_live_status_includes_error_details" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientGetLiveMetrics" name="test_get_live_metrics_extracts_keyspace_info" time="0.006" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientGetLiveMetrics" name="test_get_live_metrics_counts_live_nodes" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientGetLiveMetrics" name="test_get_live_metrics_returns_down_on_exception" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientGetLiveMetrics" name="test_get_live_metrics_skips_system_keyspaces" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientGetLiveMetrics" name="test_get_live_metrics_handles_no_replication_factor" time="0.001" /><testcase classname="src.tests.unit.backend.test_cassandra_client.TestCassandraClientGetMetricsNotConnected" name="test_get_metrics_returns_unavailable_when_not_connected" time="0.001" /><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestDataAdapterInit" name="test_init_creates_instance" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestDataAdapterInit object at 0x7b0bd4d2d590&gt;

    def test_init_creates_instance(self):
        """Test basic initialization."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:27:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestTrainingMetricsExtraction" name="test_extract_training_metrics_minimal" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestTrainingMetricsExtraction object at 0x7b0bd4d2d6d0&gt;

    def test_extract_training_metrics_minimal(self):
        """Test extracting metrics with minimal parameters."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:41:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestTrainingMetricsExtraction" name="test_extract_training_metrics_with_validation" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestTrainingMetricsExtraction object at 0x7b0bd4d2d810&gt;

    def test_extract_training_metrics_with_validation(self):
        """Test extracting metrics with validation data."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:56:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestTrainingMetricsExtraction" name="test_extract_training_metrics_with_cascade_info" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestTrainingMetricsExtraction object at 0x7b0bd4ca5810&gt;

    def test_extract_training_metrics_with_cascade_info(self):
        """Test extracting metrics with cascade phase info."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:69:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestTrainingMetricsExtraction" name="test_training_metrics_to_dict" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestTrainingMetricsExtraction object at 0x7b0bd4ca5940&gt;

    def test_training_metrics_to_dict(self):
        """Test converting training metrics to dictionary."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:82:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestNetworkTopologyConversion" name="test_convert_network_topology_simple" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestNetworkTopologyConversion object at 0x7b0bd4d2d950&gt;

    def test_convert_network_topology_simple(self):
        """Test converting simple network topology."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:102:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestNetworkTopologyConversion" name="test_convert_network_topology_with_hidden_units" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestNetworkTopologyConversion object at 0x7b0bd4d2da90&gt;

    def test_convert_network_topology_with_hidden_units(self):
        """Test converting topology with hidden units."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:128:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestNetworkTopologyConversion" name="test_convert_network_topology_to_dict" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestNetworkTopologyConversion object at 0x7b0bd4ca5a70&gt;

    def test_convert_network_topology_to_dict(self):
        """Test converting topology to dictionary."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:155:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestNodeCreation" name="test_create_input_nodes" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestNodeCreation object at 0x7b0bd4d2dbd0&gt;

    def test_create_input_nodes(self):
        """Test creating input nodes."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:187:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestNodeCreation" name="test_create_hidden_nodes" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestNodeCreation object at 0x7b0bd4d2dd10&gt;

    def test_create_hidden_nodes(self):
        """Test creating hidden nodes."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:199:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestNodeCreation" name="test_create_hidden_nodes_without_biases" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestNodeCreation object at 0x7b0bd4ca5ba0&gt;

    def test_create_hidden_nodes_without_biases(self):
        """Test creating hidden nodes without biases."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:212:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestNodeCreation" name="test_create_output_nodes" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestNodeCreation object at 0x7b0bd4ca5f30&gt;

    def test_create_output_nodes(self):
        """Test creating output nodes."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:223:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestDatasetPreparation" name="test_prepare_dataset_numpy_arrays" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestDatasetPreparation object at 0x7b0bd4d2de50&gt;

    def test_prepare_dataset_numpy_arrays(self):
        """Test preparing dataset with numpy arrays."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:240:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestDatasetPreparation" name="test_prepare_dataset_with_lists" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestDatasetPreparation object at 0x7b0bd4d2df90&gt;

    def test_prepare_dataset_with_lists(self):
        """Test preparing dataset with Python lists."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:258:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestDatasetPreparation" name="test_prepare_dataset_1d_features" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestDatasetPreparation object at 0x7b0bd4ca6060&gt;

    def test_prepare_dataset_1d_features(self):
        """Test preparing dataset with 1D features."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:272:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestDatasetPreparation" name="test_prepare_dataset_multi_class" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestDatasetPreparation object at 0x7b0bd4ca6190&gt;

    def test_prepare_dataset_multi_class(self):
        """Test preparing dataset with multiple classes."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:285:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestStateSerialization" name="test_serialize_network_state_with_tensors" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestStateSerialization object at 0x7b0bd4d2e0d0&gt;

    def test_serialize_network_state_with_tensors(self):
        """Test serializing state with torch tensors."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:302:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestStateSerialization" name="test_serialize_network_state_with_numpy" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestStateSerialization object at 0x7b0bd4d2e210&gt;

    def test_serialize_network_state_with_numpy(self):
        """Test serializing state with numpy arrays."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:316:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestStateSerialization" name="test_serialize_network_state_with_mixed_types" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestStateSerialization object at 0x7b0bd4ca62c0&gt;

    def test_serialize_network_state_with_mixed_types(self):
        """Test serializing state with mixed data types."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:329:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestStateSerialization" name="test_serialize_network_state_with_unsupported_type" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestStateSerialization object at 0x7b0bd4ca63f0&gt;

    def test_serialize_network_state_with_unsupported_type(self):
        """Test serializing state with unsupported type."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:355:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestNetworkStatistics" name="test_get_network_statistics_simple" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestNetworkStatistics object at 0x7b0bd4d2e350&gt;

    def test_get_network_statistics_simple(self):
        """Test getting statistics for simple network."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:376:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestNetworkStatistics" name="test_get_network_statistics_with_hidden_units" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestNetworkStatistics object at 0x7b0bd4d2e490&gt;

    def test_get_network_statistics_with_hidden_units(self):
        """Test getting statistics with hidden units."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:397:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestNetworkStatistics" name="test_get_network_statistics_with_topology" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestNetworkStatistics object at 0x7b0bd4ca6520&gt;

    def test_get_network_statistics_with_topology(self):
        """Test getting statistics with pre-computed topology."""
&gt;       from backend.data_adapter import DataAdapter, NetworkConnection, NetworkNode, NetworkTopology

src/tests/unit/backend/test_data_adapter_coverage.py:415:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestNetworkStatistics" name="test_invalidate_stats_cache" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestNetworkStatistics object at 0x7b0bd4ca6650&gt;

    def test_invalidate_stats_cache(self):
        """Test invalidating statistics cache."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:443:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestDataStructures" name="test_network_node_to_dict" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestDataStructures object at 0x7b0bd4d2e5d0&gt;

    def test_network_node_to_dict(self):
        """Test NetworkNode to_dict conversion."""
&gt;       from backend.data_adapter import NetworkNode

src/tests/unit/backend/test_data_adapter_coverage.py:462:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestDataStructures" name="test_network_connection_to_dict" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestDataStructures object at 0x7b0bd4d2e710&gt;

    def test_network_connection_to_dict(self):
        """Test NetworkConnection to_dict conversion."""
&gt;       from backend.data_adapter import NetworkConnection

src/tests/unit/backend/test_data_adapter_coverage.py:477:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestEdgeCases" name="test_convert_topology_with_zero_sized_network" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestEdgeCases object at 0x7b0bd4d2e850&gt;

    def test_convert_topology_with_zero_sized_network(self):
        """Test converting topology with zero-sized components."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:494:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestEdgeCases" name="test_extract_metrics_with_none_validation" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestEdgeCases object at 0x7b0bd4d2e990&gt;

    def test_extract_metrics_with_none_validation(self):
        """Test extracting metrics with None validation values."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:517:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestEdgeCases" name="test_prepare_dataset_empty_arrays" time="0.003"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestEdgeCases object at 0x7b0bd4ca6780&gt;

    def test_prepare_dataset_empty_arrays(self):
        """Test preparing dataset with empty arrays."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:530:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestEdgeCases" name="test_serialize_empty_state" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestEdgeCases object at 0x7b0bd4ca68b0&gt;

    def test_serialize_empty_state(self):
        """Test serializing empty state."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:543:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestEdgeCases" name="test_create_nodes_with_zero_size" time="0.002"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestEdgeCases object at 0x7b0bd4ccdd90&gt;

    def test_create_nodes_with_zero_size(self):
        """Test creating nodes with zero size."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestEdgeCases" name="test_get_statistics_with_no_weights" time="0.003"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestEdgeCases object at 0x7b0bd4c4d6a0&gt;

    def test_get_statistics_with_no_weights(self):
        """Test getting statistics with no weights."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:565:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_data_adapter_coverage.TestEdgeCases" name="test_network_topology_large_cascade_history" time="0.003"><failure message="ModuleNotFoundError: No module named 'scipy'">self = &lt;test_data_adapter_coverage.TestEdgeCases object at 0x7b0bd4c4d150&gt;

    def test_network_topology_large_cascade_history(self):
        """Test topology with large cascade history."""
&gt;       from backend.data_adapter import DataAdapter

src/tests/unit/backend/test_data_adapter_coverage.py:576:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/backend/data_adapter.py:44: in &lt;module&gt;
    from .statistics import compute_weight_statistics
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     statistics.py
    # Author:        Paul Calnon
    # Version:       0.1.0
    #
    # Date:          2025-11-16
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module provides comprehensive weight statistics computation for neural networks.
    #    Computes various statistical measures including mean, standard deviation, variance,
    #    skewness, kurtosis, median absolute deviation, and weight distribution analysis.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    # from typing import Dict, Any, Optional
    from typing import Any, Dict

    import numpy as np
&gt;   from scipy import stats
E   ModuleNotFoundError: No module named 'scipy'

src/backend/statistics.py:37: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.backend.test_redis_client.TestRedisClientDisabledByConfig" name="test_disabled_config_returns_disabled_status" time="0.036" /><testcase classname="src.tests.unit.backend.test_redis_client.TestRedisClientDisabledByConfig" name="test_disabled_config_returns_disabled_metrics" time="0.005" /><testcase classname="src.tests.unit.backend.test_redis_client.TestRedisClientDisabledByConfig" name="test_disabled_config_is_available_false" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestRedisClientDriverMissing" name="test_missing_driver_returns_disabled_status" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestRedisClientDriverMissing" name="test_missing_driver_is_available_false" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestRedisClientDemoMode" name="test_demo_mode_returns_up_status" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestRedisClientDemoMode" name="test_demo_mode_returns_synthetic_metrics" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestRedisClientDemoMode" name="test_demo_mode_is_available_true" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestRedisClientDemoMode" name="test_demo_mode_true_values" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestRedisClientConnectionFailure" name="test_connection_error_returns_unavailable_status" time="0.005" /><testcase classname="src.tests.unit.backend.test_redis_client.TestRedisClientConnectionFailure" name="test_connection_timeout_handles_gracefully" time="0.002" /><testcase classname="src.tests.unit.backend.test_redis_client.TestGetStatus" name="test_status_contains_required_fields" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestGetStatus" name="test_status_valid_status_values" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestGetStatus" name="test_status_valid_mode_values" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestGetStatus" name="test_status_timestamp_iso_format" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestGetMetrics" name="test_metrics_contains_required_fields" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestGetMetrics" name="test_metrics_memory_structure" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestGetMetrics" name="test_metrics_stats_structure" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestGetMetrics" name="test_metrics_clients_structure" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestGetMetrics" name="test_metrics_disabled_returns_null_metrics" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestIsAvailable" name="test_is_available_demo_mode_true" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestIsAvailable" name="test_is_available_disabled_false" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestIsAvailable" name="test_is_available_no_client_false" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestClose" name="test_close_disconnects_pool" time="0.002" /><testcase classname="src.tests.unit.backend.test_redis_client.TestClose" name="test_close_handles_none_pool" time="0.002" /><testcase classname="src.tests.unit.backend.test_redis_client.TestClose" name="test_close_handles_disconnect_error" time="0.002" /><testcase classname="src.tests.unit.backend.test_redis_client.TestSingletonPattern" name="test_get_redis_client_returns_same_instance" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestSingletonPattern" name="test_get_redis_client_force_new_creates_new" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestSingletonPattern" name="test_get_redis_client_uses_default_config" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestConfigParsing" name="test_parses_redis_url" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestConfigParsing" name="test_redis_url_env_override" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestConfigParsing" name="test_non_redis_cache_type_disabled" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestStatusConstants" name="test_status_constants_defined" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestStatusConstants" name="test_mode_constants_defined" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestPingErrorHandling" name="test_ping_returns_false_when_client_is_none" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestPingErrorHandling" name="test_ping_handles_timeout_error" time="0.002" /><testcase classname="src.tests.unit.backend.test_redis_client.TestPingErrorHandling" name="test_ping_handles_connection_error" time="0.002" /><testcase classname="src.tests.unit.backend.test_redis_client.TestGetStatusInfoRetrievalError" name="test_get_status_returns_limited_info_on_info_error" time="0.002" /><testcase classname="src.tests.unit.backend.test_redis_client.TestGetStatusInfoRetrievalError" name="test_get_status_with_full_info_success" time="0.002" /><testcase classname="src.tests.unit.backend.test_redis_client.TestGetStatusInfoRetrievalError" name="test_get_status_unavailable_when_client_none_but_enabled" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestGetMetricsLivePath" name="test_get_metrics_live_success" time="0.002" /><testcase classname="src.tests.unit.backend.test_redis_client.TestGetMetricsLivePath" name="test_get_metrics_live_with_zero_hits" time="0.002" /><testcase classname="src.tests.unit.backend.test_redis_client.TestGetMetricsLivePath" name="test_get_metrics_live_failure" time="0.002" /><testcase classname="src.tests.unit.backend.test_redis_client.TestGetRedisClientForceNew" name="test_force_new_creates_fresh_instance" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestGetRedisClientForceNew" name="test_force_new_replaces_global_instance" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestIsAvailableWithPing" name="test_is_available_calls_ping_when_client_exists" time="0.001" /><testcase classname="src.tests.unit.backend.test_redis_client.TestIsAvailableWithPing" name="test_is_available_returns_false_when_ping_fails" time="0.001" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestBaseComponentConstructor" name="test_constructor_with_minimal_config" time="0.001" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestBaseComponentConstructor" name="test_constructor_with_full_config" time="0.000" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestBaseComponentConstructor" name="test_constructor_with_special_characters_in_id" time="0.000" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestBaseComponentConstructor" name="test_constructor_with_empty_string_id" time="0.001" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestBaseComponentLogger" name="test_logger_initialized_with_correct_name" time="0.001" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestBaseComponentLogger" name="test_logger_is_logging_instance" time="0.001" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestBaseComponentLogger" name="test_different_subclasses_have_different_logger_names" time="0.001" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestAbstractMethodEnforcement" name="test_cannot_instantiate_base_class_directly" time="0.001" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestAbstractMethodEnforcement" name="test_missing_get_layout_raises_error" time="0.001" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestAbstractMethodEnforcement" name="test_missing_register_callbacks_raises_error" time="0.001" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestInitializeMethod" name="test_initialize_sets_flag" time="0.013" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestInitializeMethod" name="test_initialize_logs_message" time="0.001" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestInitializeMethod" name="test_initialize_only_runs_once" time="0.001" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestCleanupMethod" name="test_cleanup_logs_message" time="0.001" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestCleanupMethod" name="test_cleanup_can_be_called_multiple_times" time="0.001" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestGetComponentId" name="test_returns_component_id" time="0.001" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestGetComponentId" name="test_returns_same_id_as_attribute" time="0.000" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestUpdateConfig" name="test_update_config_adds_new_keys" time="0.001" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestUpdateConfig" name="test_update_config_overwrites_existing_keys" time="0.001" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestUpdateConfig" name="test_update_config_logs_debug_message" time="0.001" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestUpdateConfig" name="test_update_config_with_empty_dict" time="0.001" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestUpdateConfig" name="test_update_config_with_nested_dict" time="0.000" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestComponentLifecycle" name="test_full_lifecycle" time="0.000" /><testcase classname="src.tests.unit.frontend.test_base_component_coverage.TestComponentLifecycle" name="test_cleanup_before_initialize" time="0.000" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestSingletonBehavior" name="test_same_instance_on_multiple_calls" time="0.004" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestSingletonBehavior" name="test_reset_instance_creates_new_instance" time="0.001" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestSingletonBehavior" name="test_get_callback_context_returns_singleton" time="0.001" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestSingletonBehavior" name="test_new_instance_has_default_state" time="0.001" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestSingletonBehavior" name="test_singleton_thread_safety_lock_exists" time="0.001" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestTestModeTriggerId" name="test_set_test_trigger_enables_test_mode" time="0.001" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestTestModeTriggerId" name="test_get_triggered_id_returns_set_trigger" time="0.002" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestTestModeTriggerId" name="test_get_triggered_id_returns_none_trigger" time="0.001" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestTestModeTriggerId" name="test_clear_test_trigger_disables_test_mode" time="0.001" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestTestModeTriggerId" name="test_clear_test_trigger_clears_trigger_value" time="0.001" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestTestModeTriggerId" name="test_multiple_set_trigger_updates_value" time="0.001" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestProductionModeTriggererId" name="test_production_mode_no_dash_returns_none" time="0.001" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestProductionModeTriggererId" name="test_production_mode_dash_import_error_returns_none" time="0.001" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestProductionModeTriggererId" name="test_production_mode_dash_callback_context_error_returns_none" time="0.001"><failure message="ModuleNotFoundError: No module named 'dash'">self = &lt;src.tests.unit.frontend.test_callback_context_coverage.TestProductionModeTriggererId object at 0x7b0bd4b55e00&gt;

    def test_production_mode_dash_callback_context_error_returns_none(self):
        """If accessing callback_context raises exception, return None."""
        adapter = CallbackContextAdapter()
        adapter.clear_test_trigger()
        # Patch dash.callback_context.triggered_id to raise an exception
&gt;       with patch("dash.callback_context") as mock_ctx:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/tests/unit/frontend/test_callback_context_coverage.py:131:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:458: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'dash', import_ = &lt;function _gcd_import at 0x7b0d11133e20&gt;

&gt;   ???
E   ModuleNotFoundError: No module named 'dash'

&lt;frozen importlib._bootstrap&gt;:1335: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestGetTriggeredPropIds" name="test_test_mode_with_trigger_returns_prop_dict" time="0.001" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestGetTriggeredPropIds" name="test_test_mode_with_none_trigger_returns_empty_dict" time="0.001" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestGetTriggeredPropIds" name="test_production_mode_no_dash_returns_empty_dict" time="0.001" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestGetTriggeredPropIds" name="test_production_mode_dash_exception_returns_empty_dict" time="0.001"><failure message="ModuleNotFoundError: No module named 'dash'">self = &lt;src.tests.unit.frontend.test_callback_context_coverage.TestGetTriggeredPropIds object at 0x7b0bd4b56060&gt;

    def test_production_mode_dash_exception_returns_empty_dict(self):
        """If dash raises exception, should return empty dict."""
        adapter = CallbackContextAdapter()
        adapter.clear_test_trigger()
        # Patch dash.callback_context.triggered_prop_ids to raise an exception
&gt;       with patch("dash.callback_context") as mock_ctx:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/tests/unit/frontend/test_callback_context_coverage.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:458: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'dash', import_ = &lt;function _gcd_import at 0x7b0d11133e20&gt;

&gt;   ???
E   ModuleNotFoundError: No module named 'dash'

&lt;frozen importlib._bootstrap&gt;:1335: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestGetInputsList" name="test_test_mode_returns_empty_list" time="0.001" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestGetInputsList" name="test_production_mode_no_dash_returns_empty_list" time="0.001" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestGetInputsList" name="test_production_mode_dash_exception_returns_empty_list" time="0.001"><failure message="ModuleNotFoundError: No module named 'dash'">self = &lt;src.tests.unit.frontend.test_callback_context_coverage.TestGetInputsList object at 0x7b0bd4b56190&gt;

    def test_production_mode_dash_exception_returns_empty_list(self):
        """If dash raises exception, should return empty list."""
        adapter = CallbackContextAdapter()
        adapter.clear_test_trigger()
        # Patch dash.callback_context.inputs_list to raise an exception
&gt;       with patch("dash.callback_context") as mock_ctx:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/tests/unit/frontend/test_callback_context_coverage.py:196:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:458: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'dash', import_ = &lt;function _gcd_import at 0x7b0d11133e20&gt;

&gt;   ???
E   ModuleNotFoundError: No module named 'dash'

&lt;frozen importlib._bootstrap&gt;:1335: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestIsTestMode" name="test_is_test_mode_false_by_default" time="0.001" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestIsTestMode" name="test_is_test_mode_true_after_set_trigger" time="0.000" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestIsTestMode" name="test_is_test_mode_false_after_clear_trigger" time="0.000" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestEdgeCases" name="test_set_trigger_with_empty_string" time="0.000" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestEdgeCases" name="test_get_triggered_prop_ids_with_empty_string" time="0.000" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestEdgeCases" name="test_set_trigger_with_special_characters" time="0.000" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestEdgeCases" name="test_reset_instance_while_in_test_mode" time="0.000" /><testcase classname="src.tests.unit.frontend.test_callback_context_coverage.TestEdgeCases" name="test_singleton_persists_test_state" time="0.001" /><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelInitialization" name="test_init_with_default_config" time="0.009"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelInitialization object at 0x7b0bd4961810&gt;

    @pytest.mark.unit
    def test_init_with_default_config(self):
        """Should initialize with empty config."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:46:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelInitialization" name="test_init_with_custom_id" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelInitialization object at 0x7b0bd4961950&gt;
panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.mark.unit
    def test_init_with_custom_id(self, panel_config):
        """Should initialize with custom component ID."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:55:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelInitialization" name="test_init_sets_interval" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelInitialization object at 0x7b0bd4b56780&gt;
panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.mark.unit
    def test_init_sets_interval(self, panel_config):
        """Should set interval from config."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:63:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelInitialization" name="test_init_sets_api_timeout" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelInitialization object at 0x7b0bd4b568b0&gt;
panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.mark.unit
    def test_init_sets_api_timeout(self, panel_config):
        """Should set api_timeout from config."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:71:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelInitialization" name="test_init_uses_default_interval" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelInitialization object at 0x7b0bd493cef0&gt;

    @pytest.mark.unit
    def test_init_uses_default_interval(self):
        """Should use default interval if not in config."""
&gt;       from frontend.components.cassandra_panel import (
            DEFAULT_REFRESH_INTERVAL_MS,
            CassandraPanel,
        )

src/tests/unit/frontend/test_cassandra_panel.py:79:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelInitialization" name="test_init_uses_default_timeout" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelInitialization object at 0x7b0bd492d150&gt;

    @pytest.mark.unit
    def test_init_uses_default_timeout(self):
        """Should use default timeout if not in config."""
&gt;       from frontend.components.cassandra_panel import (
            DEFAULT_API_TIMEOUT_SECONDS,
            CassandraPanel,
        )

src/tests/unit/frontend/test_cassandra_panel.py:90:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelLayout" name="test_get_layout_returns_div" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelLayout" name="test_layout_contains_interval" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelLayout" name="test_layout_contains_status_badge" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelLayout" name="test_layout_contains_cluster_card" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelLayout" name="test_layout_contains_schema_card" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelRenderHostsTable" name="test_render_hosts_table_empty_list" time="0.003"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelRenderHostsTable" name="test_render_hosts_table_single_host" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelRenderHostsTable" name="test_render_hosts_table_multiple_hosts" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelRenderHostsTable" name="test_render_hosts_table_missing_fields" time="0.001"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelApiUrl" name="test_api_url_strips_leading_slash" time="0.001"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelApiUrl" name="test_api_url_handles_no_leading_slash" time="0.001"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelStatusColors" name="test_status_colors_up" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelStatusColors" name="test_status_colors_down" time="0.001"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelStatusColors" name="test_status_colors_disabled" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelStatusColors" name="test_status_colors_unavailable" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelStatusColors" name="test_mode_colors_demo" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelStatusColors" name="test_mode_colors_live" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelStatusColors" name="test_mode_colors_disabled" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelCallbacks" name="test_register_callbacks_creates_callback" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelCallbacks" name="test_callback_returns_expected_outputs" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelCallbacks" name="test_callback_handles_api_success" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelErrorHandling" name="test_callback_handles_connection_timeout" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelErrorHandling" name="test_callback_handles_connection_error" time="0.001"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelErrorHandling" name="test_callback_handles_http_503" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelErrorHandling" name="test_callback_handles_http_error" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelErrorHandling" name="test_callback_handles_json_decode_error" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelErrorHandling" name="test_callback_handles_metrics_timeout_gracefully" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelComponentIds" name="test_component_ids_use_panel_id" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_cassandra_panel.TestCassandraPanelComponentIds" name="test_interval_id_includes_component_id" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">panel_config = {'api_timeout': 3, 'interval_ms': 5000}

    @pytest.fixture
    def panel(panel_config):
        """Create CassandraPanel instance."""
&gt;       from frontend.components.cassandra_panel import CassandraPanel

src/tests/unit/frontend/test_cassandra_panel.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # File Name:     cassandra_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Cassandra monitoring panel component displaying cluster status, schema information,
    #    and real-time health metrics for the Cassandra backend integration.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Cassandra Monitoring Panel Component
    #
    # Provides real-time monitoring of Cassandra cluster status including:
    # - Connection status (UP/DOWN/DISABLED/UNAVAILABLE)
    # - Mode indicator (DEMO/LIVE/DISABLED)
    # - Cluster overview with host status table
    # - Schema overview with keyspace and table counts
    # - Error message display for connection issues
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Cassandra monitoring
    #
    #####################################################################################################################################################################################################
    from typing import Any, Dict, List, Optional

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/cassandra_panel.py:45: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestRedisPanelLayout" name="test_layout_returns_div" time="0.010"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestRedisPanelLayout" name="test_layout_has_component_id" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestRedisPanelLayout" name="test_layout_contains_status_badge" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestRedisPanelLayout" name="test_layout_contains_mode_badge" time="0.001"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestRedisPanelLayout" name="test_layout_contains_health_card" time="0.001"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestRedisPanelLayout" name="test_layout_contains_metrics_card" time="0.001"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestRedisPanelLayout" name="test_layout_contains_version_field" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestRedisPanelLayout" name="test_layout_contains_uptime_field" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestRedisPanelLayout" name="test_layout_contains_clients_field" time="0.001"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestRedisPanelLayout" name="test_layout_contains_latency_field" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestRedisPanelLayout" name="test_layout_contains_memory_field" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestRedisPanelLayout" name="test_layout_contains_ops_sec_field" time="0.001"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestRedisPanelLayout" name="test_layout_contains_hit_rate_field" time="0.001"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestRedisPanelLayout" name="test_layout_contains_keyspace_field" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestRedisPanelLayout" name="test_layout_contains_interval_component" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestRedisPanelLayout" name="test_layout_contains_error_display" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestApiUrlHelper" name="test_api_url_builds_correct_path" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestApiUrlHelper" name="test_api_url_uses_config_base_url" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestApiUrlHelper object at 0x7b0bd3ca9310&gt;
config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    def test_api_url_uses_config_base_url(self, config):
        """_api_url uses api_base_url from config."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:154:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestApiUrlHelper" name="test_api_url_default_base_url" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestApiUrlHelper object at 0x7b0bd42fad70&gt;

    def test_api_url_default_base_url(self):
        """_api_url uses default localhost:8050 when not configured."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:164:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackRegistration" name="test_register_callbacks_decorates_app" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackRegistration" name="test_register_callbacks_stores_function" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackRegistration" name="test_callback_has_correct_output_count" time="0.003"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackRegistration" name="test_callback_has_correct_input" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestStatusColorMapping" name="test_status_colors_are_bootstrap_valid" time="0.001" /><testcase classname="src.tests.unit.frontend.test_redis_panel.TestStatusColorMapping" name="test_mode_colors_are_bootstrap_valid" time="0.001" /><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_uptime_seconds" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_uptime_minutes" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_uptime_hours" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_uptime_days" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_uptime_none" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_uptime_invalid" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_latency" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_latency_none" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_memory_bytes" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_memory_kilobytes" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_memory_megabytes" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_memory_gigabytes" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_memory_none" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_hit_rate" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_hit_rate_none" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_keyspace_dict" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_keyspace_int" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_keyspace_none" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_keyspace_multiple_dbs" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_uptime_zero" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_latency_zero" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingHelpers" name="test_format_memory_zero" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestIntervalConfiguration" name="test_default_interval" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestIntervalConfiguration object at 0x7b0bd3ca9bd0&gt;

    def test_default_interval(self):
        """Default interval is 5000ms."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:352:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestIntervalConfiguration" name="test_config_interval_override" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestIntervalConfiguration object at 0x7b0bd3ca9d10&gt;

    def test_config_interval_override(self):
        """Config interval overrides default."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:359:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestIntervalConfiguration" name="test_env_var_interval_override" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestIntervalConfiguration object at 0x7b0bd42fb360&gt;
monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7b0bd013b3f0&gt;

    def test_env_var_interval_override(self, monkeypatch):
        """Environment variable overrides default."""
        monkeypatch.setenv("JUNIPER_CANOPY_REDIS_REFRESH_INTERVAL_MS", "3000")

&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:368:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestIntervalConfiguration" name="test_invalid_env_var_uses_default" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestIntervalConfiguration object at 0x7b0bd42fb490&gt;
monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7b0bd0104050&gt;

    def test_invalid_env_var_uses_default(self, monkeypatch):
        """Invalid env var falls back to default."""
        monkeypatch.setenv("JUNIPER_CANOPY_REDIS_REFRESH_INTERVAL_MS", "invalid")

&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:377:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestIntervalConfiguration" name="test_config_priority_over_env" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestIntervalConfiguration object at 0x7b0bd3cae450&gt;
monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7b0bd0106900&gt;

    def test_config_priority_over_env(self, monkeypatch):
        """Config takes priority over environment variable."""
        monkeypatch.setenv("JUNIPER_CANOPY_REDIS_REFRESH_INTERVAL_MS", "3000")

&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:386:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestApiTimeout" name="test_default_timeout" time="0.003"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestApiTimeout object at 0x7b0bd3ca9e50&gt;

    def test_default_timeout(self):
        """Default timeout is 2 seconds."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:398:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestApiTimeout" name="test_config_timeout_override" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestApiTimeout object at 0x7b0bd3ca9f90&gt;

    def test_config_timeout_override(self):
        """Config timeout overrides default."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:405:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestComponentId" name="test_default_component_id" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestComponentId object at 0x7b0bd3caa0d0&gt;

    def test_default_component_id(self):
        """Default component id is 'redis-panel'."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:417:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestComponentId" name="test_custom_component_id" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestComponentId object at 0x7b0bd3caa210&gt;

    def test_custom_component_id(self):
        """Custom component id is used."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:424:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestComponentId" name="test_component_id_in_layout" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestBaseComponentInheritance" name="test_inherits_from_base_component" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestBaseComponentInheritance" name="test_has_logger" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestBaseComponentInheritance" name="test_has_config" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestLayoutOutputIds" name="test_status_badge_id_matches" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestLayoutOutputIds" name="test_mode_badge_id_matches" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestLayoutOutputIds" name="test_version_id_matches" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestLayoutOutputIds" name="test_uptime_id_matches" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestLayoutOutputIds" name="test_clients_id_matches" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestLayoutOutputIds" name="test_latency_id_matches" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestLayoutOutputIds" name="test_memory_id_matches" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestLayoutOutputIds" name="test_ops_sec_id_matches" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestLayoutOutputIds" name="test_hit_rate_id_matches" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestLayoutOutputIds" name="test_keyspace_id_matches" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestLayoutOutputIds" name="test_refresh_interval_id_matches" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestLayoutOutputIds" name="test_error_display_id_matches" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackExecution" name="test_callback_success_up_status" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestCallbackExecution object at 0x7b0bd3caa850&gt;

    def test_callback_success_up_status(self):
        """Test callback with successful UP status response."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:537:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackExecution" name="test_callback_success_down_status" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestCallbackExecution object at 0x7b0bd3caa990&gt;

    def test_callback_success_down_status(self):
        """Test callback with DOWN status response."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:581:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackExecution" name="test_callback_success_disabled_status" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestCallbackExecution object at 0x7b0bd42fba80&gt;

    def test_callback_success_disabled_status(self):
        """Test callback with DISABLED status response."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:611:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackExecution" name="test_callback_success_demo_mode" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestCallbackExecution object at 0x7b0bd42fbbb0&gt;

    def test_callback_success_demo_mode(self):
        """Test callback with DEMO mode response."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:643:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackExecution" name="test_callback_status_timeout" time="0.001"><failure message="ModuleNotFoundError: No module named 'requests'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestCallbackExecution object at 0x7b0bd3cae570&gt;

    def test_callback_status_timeout(self):
        """Test callback handles status API timeout."""
&gt;       import requests
E       ModuleNotFoundError: No module named 'requests'

src/tests/unit/frontend/test_redis_panel.py:673: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackExecution" name="test_callback_status_connection_error" time="0.001"><failure message="ModuleNotFoundError: No module named 'requests'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestCallbackExecution object at 0x7b0bd3d22030&gt;

    def test_callback_status_connection_error(self):
        """Test callback handles status API connection error."""
&gt;       import requests
E       ModuleNotFoundError: No module named 'requests'

src/tests/unit/frontend/test_redis_panel.py:693: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackExecution" name="test_callback_status_generic_exception" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestCallbackExecution object at 0x7b0bd3d22140&gt;

    def test_callback_status_generic_exception(self):
        """Test callback handles generic exception during status fetch."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:713:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackExecution" name="test_callback_metrics_timeout" time="0.001"><failure message="ModuleNotFoundError: No module named 'requests'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestCallbackExecution object at 0x7b0bd3cbe750&gt;

    def test_callback_metrics_timeout(self):
        """Test callback handles metrics API timeout."""
&gt;       import requests
E       ModuleNotFoundError: No module named 'requests'

src/tests/unit/frontend/test_redis_panel.py:730: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackExecution" name="test_callback_metrics_connection_error" time="0.001"><failure message="ModuleNotFoundError: No module named 'requests'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestCallbackExecution object at 0x7b0bd3cbe950&gt;

    def test_callback_metrics_connection_error(self):
        """Test callback handles metrics API connection error."""
&gt;       import requests
E       ModuleNotFoundError: No module named 'requests'

src/tests/unit/frontend/test_redis_panel.py:756: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackExecution" name="test_callback_metrics_generic_exception" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestCallbackExecution object at 0x7b0bd3ca64e0&gt;

    def test_callback_metrics_generic_exception(self):
        """Test callback handles generic exception during metrics fetch."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:780:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackExecution" name="test_callback_unknown_status" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestCallbackExecution object at 0x7b0bd3ca66c0&gt;

    def test_callback_unknown_status(self):
        """Test callback handles unknown status value."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:801:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackExecution" name="test_callback_connected_status" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestCallbackExecution object at 0x7b0bd3cd02f0&gt;

    def test_callback_connected_status(self):
        """Test callback handles CONNECTED status (alias for UP)."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:833:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackExecution" name="test_callback_disconnected_status" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestCallbackExecution object at 0x7b0bd3cd0670&gt;

    def test_callback_disconnected_status(self):
        """Test callback handles DISCONNECTED status (alias for DOWN)."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:863:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackExecution" name="test_callback_non_200_status_response" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestCallbackExecution object at 0x7b0bd4255a50&gt;

    def test_callback_non_200_status_response(self):
        """Test callback handles non-200 status response."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:893:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackExecution" name="test_callback_non_200_metrics_response" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash_bootstrap_components'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestCallbackExecution object at 0x7b0bd4266450&gt;

    def test_callback_non_200_metrics_response(self):
        """Test callback handles non-200 metrics response."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:918:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestCallbackExecution" name="test_callback_no_error_when_status_fails_but_has_existing_error" time="0.001"><failure message="ModuleNotFoundError: No module named 'requests'">self = &lt;src.tests.unit.frontend.test_redis_panel.TestCallbackExecution object at 0x7b0bd4266510&gt;

    def test_callback_no_error_when_status_fails_but_has_existing_error(self):
        """Test that metrics timeout doesn't overwrite existing status error."""
&gt;       import requests
E       ModuleNotFoundError: No module named 'requests'

src/tests/unit/frontend/test_redis_panel.py:947: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingEdgeCases" name="test_format_uptime_invalid_type" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingEdgeCases" name="test_format_uptime_negative" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingEdgeCases" name="test_format_latency_invalid_type" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingEdgeCases" name="test_format_memory_invalid_type" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingEdgeCases" name="test_format_hit_rate_invalid_type" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.frontend.test_redis_panel.TestFormattingEdgeCases" name="test_format_keyspace_string" time="0.002"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'dash_bootstrap_components'&quot;">config = {'api_base_url': 'http://localhost:8050', 'api_timeout': 2, 'interval_ms': 5000}

    @pytest.fixture
    def redis_panel(config):
        """Create RedisPanel instance."""
&gt;       from frontend.components.redis_panel import RedisPanel

src/tests/unit/frontend/test_redis_panel.py:37:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     redis_panel.py
    # Author:        Paul Calnon
    # Version:       1.0.0
    #
    # Date:          2026-01-09
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2026 Paul Calnon
    #
    # Description:
    #    Redis monitoring panel component displaying Redis connection status, health metrics,
    #    and performance statistics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Redis Monitoring Panel Component
    #
    # Real-time monitoring panel for Redis connection health, memory usage, operations
    # per second, cache hit rate, and keyspace statistics. Supports DEMO/LIVE/DISABLED modes.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #   - Initial implementation for Redis monitoring dashboard
    #
    #####################################################################################################################################################################################################
    import os
    from typing import Any, Dict

&gt;   import dash_bootstrap_components as dbc
E   ModuleNotFoundError: No module named 'dash_bootstrap_components'

src/frontend/components/redis_panel.py:41: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_config_manager.TestConfigManager" name="test_initialization_with_valid_config" time="0.007" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManager" name="test_initialization_without_config_file" time="0.002" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManager" name="test_get_nested_key_access" time="0.004" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManager" name="test_get_with_default_value" time="0.003" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManager" name="test_get_without_default_returns_none" time="0.003" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManager" name="test_set_configuration_value" time="0.003" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManager" name="test_set_overwrites_existing_value" time="0.003" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManager" name="test_get_section" time="0.003" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManager" name="test_get_section_nonexistent_returns_empty_dict" time="0.002" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManager" name="test_to_dict_returns_copy" time="0.002" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManager" name="test_environment_variable_override_simple" time="0.003" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManager" name="test_environment_variable_override_nested" time="0.003" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManager" name="test_environment_variable_creates_new_keys" time="0.002" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManager" name="test_type_conversion_boolean_true" time="0.003" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManager" name="test_type_conversion_boolean_false" time="0.003" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManager" name="test_type_conversion_integer" time="0.003" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManager" name="test_type_conversion_float" time="0.003" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManager" name="test_type_conversion_string_fallback" time="0.003" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManager" name="test_reload_configuration" time="0.003" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManagerSingleton" name="test_get_config_returns_instance" time="0.001" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManagerSingleton" name="test_get_config_singleton_behavior" time="0.003" /><testcase classname="src.tests.unit.test_config_manager.TestConfigManagerSingleton" name="test_singleton_persists_modifications" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_advanced.TestConfigEnvVarExpansion" name="test_simple_env_var_expansion" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_advanced.TestConfigEnvVarExpansion" name="test_nested_env_var_expansion" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_advanced.TestConfigEnvVarExpansion" name="test_env_var_expansion_in_lists" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_advanced.TestConfigEnvOverrides" name="test_simple_override" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_advanced.TestConfigEnvOverrides" name="test_type_conversion" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_advanced.TestConfigEnvOverrides" name="test_nested_override_collision" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_advanced.TestConfigValidation" name="test_missing_required_keys" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_advanced.TestConfigValidation" name="test_invalid_type_correction" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_advanced.TestConfigReload" name="test_force_reload" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_advanced.TestConfigReload" name="test_reload_method" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_advanced.TestConfigAccessors" name="test_get_with_default" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_advanced.TestConfigAccessors" name="test_set_nested_path" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_advanced.TestConfigAccessors" name="test_get_section" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestEnvVarExpansionEdgeCases" name="test_expand_undefined_env_var_unchanged" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestEnvVarExpansionEdgeCases" name="test_expand_env_var_with_special_chars" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestEnvVarExpansionEdgeCases" name="test_expand_multiple_env_vars_in_one_value" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestEnvVarExpansionEdgeCases" name="test_expand_env_vars_in_deeply_nested_dict" time="0.004" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestEnvVarExpansionEdgeCases" name="test_expand_preserves_non_string_types" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestNestedOverrideCollision" name="test_override_replaces_int_with_dict" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestNestedOverrideCollision" name="test_override_replaces_list_with_dict" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestNestedOverrideCollision" name="test_override_deeply_nested_collision" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestNestedOverrideCollision" name="test_override_creates_intermediate_dicts" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestTrainingParamValidation" name="test_validate_param_at_min_boundary" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestTrainingParamValidation" name="test_validate_param_at_max_boundary" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestTrainingParamValidation" name="test_validate_param_below_min_raises" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestTrainingParamValidation" name="test_validate_param_above_max_raises" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestTrainingParamValidation" name="test_validate_param_nonexistent_raises_keyerror" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestTrainingParamValidation" name="test_get_training_param_config_missing_keys_raises" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestTrainingParamValidation" name="test_get_training_param_config_invalid_range_raises" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestTrainingParamValidation" name="test_is_param_modifiable_during_training" time="0.004" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestGetTrainingDefaults" name="test_get_training_defaults_returns_all_defaults" time="0.004" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestGetTrainingDefaults" name="test_get_training_defaults_empty_params" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestGetTrainingDefaults" name="test_get_training_defaults_no_training_section" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestConfigReloadAndForceReload" name="test_force_reload_creates_new_instance" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestConfigReloadAndForceReload" name="test_reload_applies_new_env_overrides" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestConfigReloadAndForceReload" name="test_reload_revalidates_config" time="0.004" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestConfigLoadErrors" name="test_load_malformed_yaml_returns_empty" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestConfigLoadErrors" name="test_load_empty_file_returns_empty_config" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestConstantsConsistency" name="test_verify_constants_with_missing_module" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestConstantsConsistency" name="test_verify_constants_with_mock_class" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestConstantsConsistency" name="test_verify_constants_detects_mismatch" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestConstantsConsistency" name="test_skipping_constants_check_returns_true_when_unavailable" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestGetPathEdgeCases" name="test_get_from_non_dict_intermediate" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestGetPathEdgeCases" name="test_get_single_key" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestTypeConversionEdgeCases" name="test_convert_yes_no_variants" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestTypeConversionEdgeCases" name="test_convert_negative_numbers" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestToDictMethod" name="test_to_dict_returns_complete_config" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestToDictMethod" name="test_to_dict_returns_independent_copy" time="0.002" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestCheckConstantsCategory" name="test_check_constants_category_with_matching_values" time="0.006" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestCheckConstantsCategory" name="test_check_constants_category_with_mismatch" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestCheckConstantsCategory" name="test_check_constants_category_uses_class_name" time="0.003" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestDefaultPathHandling" name="test_default_config_path_when_none_provided" time="0.019" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestVerifyConstantsWithMissingAttribute" name="test_verify_constants_missing_attribute" time="0.004" /><testcase classname="src.tests.unit.test_config_manager_comprehensive.TestVerifyConstantsWithMissingAttribute" name="test_verify_constants_missing_param_in_config" time="0.003" /><testcase classname="src.tests.unit.test_config_refactoring.TestServerConfiguration" name="test_server_host_from_config" time="0.023" /><testcase classname="src.tests.unit.test_config_refactoring.TestServerConfiguration" name="test_server_host_from_env" time="0.005" /><testcase classname="src.tests.unit.test_config_refactoring.TestServerConfiguration" name="test_server_port_from_config" time="0.031" /><testcase classname="src.tests.unit.test_config_refactoring.TestServerConfiguration" name="test_server_port_from_env" time="0.005" /><testcase classname="src.tests.unit.test_config_refactoring.TestServerConfiguration" name="test_server_debug_from_env" time="0.009" /><testcase classname="src.tests.unit.test_config_refactoring.TestDashboardConfiguration" name="test_training_defaults_load" time="0.021" /><testcase classname="src.tests.unit.test_config_refactoring.TestDashboardConfiguration" name="test_learning_rate_from_env" time="0.006" /><testcase classname="src.tests.unit.test_config_refactoring.TestDashboardConfiguration" name="test_epochs_from_env" time="0.005" /><testcase classname="src.tests.unit.test_config_refactoring.TestDashboardConfiguration" name="test_hidden_units_from_env" time="0.006" /><testcase classname="src.tests.unit.test_config_refactoring.TestDashboardConfiguration" name="test_invalid_env_var_handling" time="0.005" /><testcase classname="src.tests.unit.test_config_refactoring.TestMetricsPanelConfiguration" name="test_update_interval_from_config" time="0.020" /><testcase classname="src.tests.unit.test_config_refactoring.TestMetricsPanelConfiguration" name="test_update_interval_from_env" time="0.005" /><testcase classname="src.tests.unit.test_config_refactoring.TestMetricsPanelConfiguration" name="test_buffer_size_from_env" time="0.006" /><testcase classname="src.tests.unit.test_config_refactoring.TestMetricsPanelConfiguration" name="test_smoothing_window_from_env" time="0.005" /><testcase classname="src.tests.unit.test_config_refactoring.TestBackendIntegrationConfiguration" name="test_backend_path_from_config" time="0.021" /><testcase classname="src.tests.unit.test_config_refactoring.TestBackendIntegrationConfiguration" name="test_backend_path_from_env" time="0.005" /><testcase classname="src.tests.unit.test_config_refactoring.TestBackendIntegrationConfiguration" name="test_backend_path_expansion" time="0.005" /><testcase classname="src.tests.unit.test_config_refactoring.TestWebSocketConfiguration" name="test_max_connections_constant" time="0.001" /><testcase classname="src.tests.unit.test_config_refactoring.TestWebSocketConfiguration" name="test_max_connections_from_env" time="0.005" /><testcase classname="src.tests.unit.test_config_refactoring.TestWebSocketConfiguration" name="test_heartbeat_interval_from_env" time="0.005" /><testcase classname="src.tests.unit.test_config_refactoring.TestWebSocketConfiguration" name="test_reconnect_attempts_from_env" time="0.005" /><testcase classname="src.tests.unit.test_config_refactoring.TestWebSocketConfiguration" name="test_reconnect_delay_from_env" time="0.005" /><testcase classname="src.tests.unit.test_config_refactoring.TestDemoModeConfiguration" name="test_demo_update_interval_from_env" time="0.006" /><testcase classname="src.tests.unit.test_config_refactoring.TestDemoModeConfiguration" name="test_demo_cascade_frequency_from_env" time="0.007" /><testcase classname="src.tests.unit.test_config_refactoring.TestDemoModeConfiguration" name="test_demo_uses_training_defaults" time="0.025" /><testcase classname="src.tests.unit.test_config_refactoring.TestConfigurationHierarchy" name="test_hierarchy_env_wins" time="0.025" /><testcase classname="src.tests.unit.test_config_refactoring.TestConfigurationHierarchy" name="test_hierarchy_config_over_constant" time="0.021" /><testcase classname="src.tests.unit.test_config_refactoring.TestConfigurationHierarchy" name="test_hierarchy_constant_fallback" time="0.006" /><testcase classname="src.tests.unit.test_config_refactoring.TestConfigValidation" name="test_training_param_validation" time="0.021" /><testcase classname="src.tests.unit.test_config_refactoring.TestConfigValidation" name="test_training_param_value_validation" time="0.021" /><testcase classname="src.tests.unit.test_config_refactoring.TestConstantsConsistency" name="test_training_constants_exist" time="0.001" /><testcase classname="src.tests.unit.test_config_refactoring.TestConstantsConsistency" name="test_dashboard_constants_exist" time="0.001" /><testcase classname="src.tests.unit.test_config_refactoring.TestConstantsConsistency" name="test_server_constants_exist" time="0.001" /><testcase classname="src.tests.unit.test_config_refactoring.TestConstantsConsistency" name="test_websocket_constants_exist" time="0.001" /><testcase classname="src.tests.unit.test_config_refactoring.TestConstantsConsistency" name="test_training_constants_ranges" time="0.001" /><testcase classname="src.tests.unit.test_config_training_params.TestTrainingParameterConfig" name="test_get_epochs_config" time="0.030" /><testcase classname="src.tests.unit.test_config_training_params.TestTrainingParameterConfig" name="test_get_learning_rate_config" time="0.090" /><testcase classname="src.tests.unit.test_config_training_params.TestTrainingParameterConfig" name="test_get_hidden_units_config" time="0.023" /><testcase classname="src.tests.unit.test_config_training_params.TestTrainingParameterConfig" name="test_invalid_parameter_name" time="0.020" /><testcase classname="src.tests.unit.test_config_training_params.TestTrainingParameterConfig" name="test_validate_valid_epochs" time="0.018" /><testcase classname="src.tests.unit.test_config_training_params.TestTrainingParameterConfig" name="test_validate_invalid_epochs" time="0.019" /><testcase classname="src.tests.unit.test_config_training_params.TestTrainingParameterConfig" name="test_validate_valid_learning_rate" time="0.019" /><testcase classname="src.tests.unit.test_config_training_params.TestTrainingParameterConfig" name="test_validate_invalid_learning_rate" time="0.019" /><testcase classname="src.tests.unit.test_config_training_params.TestTrainingParameterConfig" name="test_get_training_defaults" time="0.019" /><testcase classname="src.tests.unit.test_config_training_params.TestTrainingParameterConfig" name="test_param_modifiability" time="0.022" /><testcase classname="src.tests.unit.test_config_training_params.TestTrainingParameterConfig" name="test_training_param_config_structure" time="0.019" /><testcase classname="src.tests.unit.test_config_training_params.TestConfigConstantsConsistency" name="test_config_constants_consistency" time="0.024" /><testcase classname="src.tests.unit.test_config_training_params.TestConfigConstantsConsistency" name="test_epochs_compatible_with_constants" time="0.020" /><testcase classname="src.tests.unit.test_config_training_params.TestConfigConstantsConsistency" name="test_learning_rate_compatible_with_constants" time="0.020" /><testcase classname="src.tests.unit.test_config_training_params.TestConfigConstantsConsistency" name="test_hidden_units_compatible_with_constants" time="0.019" /><testcase classname="src.tests.unit.test_config_training_params.TestConfigConstantsConsistency" name="test_defaults_within_valid_bounds" time="0.019" /><testcase classname="src.tests.unit.test_config_training_params.TestConfigTrainingBehavior" name="test_training_behavior_exists" time="0.019" /><testcase classname="src.tests.unit.test_config_training_params.TestConfigTrainingBehavior" name="test_training_behavior_values" time="0.021" /><testcase classname="src.tests.unit.test_config_training_params.TestConfigTrainingMonitoring" name="test_training_monitoring_exists" time="0.021" /><testcase classname="src.tests.unit.test_config_training_params.TestConfigTrainingMonitoring" name="test_training_monitoring_values" time="0.034" /><testcase classname="src.tests.unit.test_constants.TestTrainingConstants" name="test_epoch_constraints" time="0.001" /><testcase classname="src.tests.unit.test_constants.TestTrainingConstants" name="test_learning_rate_constraints" time="0.001" /><testcase classname="src.tests.unit.test_constants.TestTrainingConstants" name="test_hidden_units_constraints" time="0.001" /><testcase classname="src.tests.unit.test_constants.TestTrainingConstants" name="test_constants_are_integers" time="0.001" /><testcase classname="src.tests.unit.test_constants.TestTrainingConstants" name="test_constants_are_floats" time="0.001" /><testcase classname="src.tests.unit.test_constants.TestTrainingConstants" name="test_positive_values" time="0.001" /><testcase classname="src.tests.unit.test_constants.TestDashboardConstants" name="test_update_intervals" time="0.001" /><testcase classname="src.tests.unit.test_constants.TestDashboardConstants" name="test_api_timeout" time="0.001" /><testcase classname="src.tests.unit.test_constants.TestDashboardConstants" name="test_data_limits" time="0.001" /><testcase classname="src.tests.unit.test_constants.TestDashboardConstants" name="test_positive_values" time="0.001" /><testcase classname="src.tests.unit.test_constants.TestServerConstants" name="test_default_host" time="0.001" /><testcase classname="src.tests.unit.test_constants.TestServerConstants" name="test_default_port" time="0.001" /><testcase classname="src.tests.unit.test_constants.TestServerConstants" name="test_websocket_paths" time="0.001" /><testcase classname="src.tests.unit.test_constants.TestModuleLevelConvenience" name="test_convenience_imports" time="0.001" /><testcase classname="src.tests.unit.test_demo_mode_advanced.TestDemoModeThreadSafety" name="test_concurrent_state_access" time="0.139" /><testcase classname="src.tests.unit.test_demo_mode_advanced.TestDemoModeThreadSafety" name="test_start_stop_idempotency" time="0.035" /><testcase classname="src.tests.unit.test_demo_mode_advanced.TestDemoModeThreadSafety" name="test_pause_resume_correctness" time="1.133" /><testcase classname="src.tests.unit.test_demo_mode_advanced.TestDemoModeThreadSafety" name="test_pause_without_running" time="0.050" /><testcase classname="src.tests.unit.test_demo_mode_advanced.TestDemoModeThreadSafety" name="test_reset_functionality" time="0.524" /><testcase classname="src.tests.unit.test_demo_mode_advanced.TestDemoModeThreadSafety" name="test_stop_completes_promptly" time="0.550" /><testcase classname="src.tests.unit.test_demo_mode_advanced.TestDemoModeThreadSafety" name="test_metrics_history_bounded" time="2.045" /><testcase classname="src.tests.unit.test_demo_mode_advanced.TestDemoModeThreadSafety" name="test_network_history_bounded" time="2.024" /><testcase classname="src.tests.unit.test_demo_mode_advanced.TestDemoModeSingleton" name="test_singleton_returns_same_instance" time="0.049" /><testcase classname="src.tests.unit.test_demo_mode_advanced.TestDemoModeSingleton" name="test_singleton_state_persistence" time="0.301" /><testcase classname="src.tests.unit.test_demo_mode_advanced.TestDemoModeDataGeneration" name="test_dataset_generation" time="0.022" /><testcase classname="src.tests.unit.test_demo_mode_advanced.TestDemoModeDataGeneration" name="test_metrics_consistency" time="0.522" /><testcase classname="src.tests.unit.test_demo_mode_advanced.TestDemoModeDataGeneration" name="test_cascade_unit_addition" time="1.041" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestMockCascorNetwork" name="test_network_initialization" time="0.002" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestMockCascorNetwork" name="test_forward_no_hidden_units" time="0.008" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestMockCascorNetwork" name="test_forward_with_hidden_units" time="0.002" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestMockCascorNetwork" name="test_add_hidden_unit_updates_output_weights" time="0.003" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestMockCascorNetwork" name="test_hidden_unit_structure" time="0.002" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestMockCascorNetwork" name="test_history_is_bounded_deque" time="0.002" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeEnvironmentVariables" name="test_invalid_update_interval_env" time="0.037" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeEnvironmentVariables" name="test_valid_update_interval_env" time="0.024" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeEnvironmentVariables" name="test_invalid_epochs_env" time="0.025" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeEnvironmentVariables" name="test_valid_epochs_env" time="0.025" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeEnvironmentVariables" name="test_invalid_hidden_units_env" time="0.024" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeEnvironmentVariables" name="test_valid_hidden_units_env" time="0.028" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeEnvironmentVariables" name="test_invalid_cascade_every_env" time="0.029" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeEnvironmentVariables" name="test_valid_cascade_every_env" time="0.026" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeTrainingStateUnavailable" name="test_training_state_import_error" time="0.020" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeBroadcastFailures" name="test_broadcast_metrics_import_error" time="0.024"><failure message="AttributeError: module 'communication' has no attribute 'websocket_manager'">self = &lt;src.tests.unit.test_demo_mode_comprehensive.TestDemoModeBroadcastFailures object at 0x7b0bd41edf90&gt;

    def test_broadcast_metrics_import_error(self):
        """Test _broadcast_metrics handles ImportError (lines 598-600).

        This test verifies the broadcast method handles import errors gracefully.
        We patch the websocket_manager's broadcast method to simulate the error
        occurring at the websocket layer rather than patching DemoMode's method,
        which would cause unhandled thread exceptions.
        """
        demo = DemoMode(update_interval=0.1)

&gt;       with patch(
            "communication.websocket_manager.websocket_manager.broadcast_from_thread",
            side_effect=ImportError("Module not available"),
        ):

src/tests/unit/test_demo_mode_comprehensive.py:184:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'communication.websocket_manager.websocket_manager'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'communication' has no attribute 'websocket_manager'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeBroadcastFailures" name="test_broadcast_metrics_generic_exception" time="0.224" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeBroadcastFailures" name="test_broadcast_cascade_import_error" time="0.026" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeBroadcastFailures" name="test_broadcast_cascade_generic_exception" time="0.026"><failure message="AttributeError: module 'communication' has no attribute 'websocket_manager'">self = &lt;src.tests.unit.test_demo_mode_comprehensive.TestDemoModeBroadcastFailures object at 0x7b0bd41dd220&gt;

    def test_broadcast_cascade_generic_exception(self):
        """Test _broadcast_cascade_add handles generic exception (lines 621-622)."""
        demo = DemoMode(update_interval=0.1)

&gt;       with patch(
            "communication.websocket_manager.websocket_manager.broadcast_from_thread",
            side_effect=Exception("Broadcast failed"),
        ):

src/tests/unit/test_demo_mode_comprehensive.py:208:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'communication.websocket_manager.websocket_manager'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'communication' has no attribute 'websocket_manager'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeBroadcastFailures" name="test_broadcast_status_import_error" time="0.025" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeBroadcastFailures" name="test_broadcast_status_generic_exception" time="0.026"><failure message="AttributeError: module 'communication' has no attribute 'websocket_manager'">self = &lt;src.tests.unit.test_demo_mode_comprehensive.TestDemoModeBroadcastFailures object at 0x7b0bd41d0160&gt;

    def test_broadcast_status_generic_exception(self):
        """Test _broadcast_status handles generic exception (lines 862-863)."""
        demo = DemoMode()

&gt;       with patch(
            "communication.websocket_manager.websocket_manager.broadcast_from_thread",
            side_effect=Exception("Status broadcast failed"),
        ):

src/tests/unit/test_demo_mode_comprehensive.py:223:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'communication.websocket_manager.websocket_manager'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'communication' has no attribute 'websocket_manager'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeBroadcastFailures" name="test_broadcast_state_exception" time="0.027"><failure message="AttributeError: module 'communication' has no attribute 'websocket_manager'">self = &lt;src.tests.unit.test_demo_mode_comprehensive.TestDemoModeBroadcastFailures object at 0x7b0bd41d0270&gt;

    def test_broadcast_state_exception(self):
        """Test _broadcast_state handles exception (lines 360-363)."""
        demo = DemoMode()

&gt;       with patch(
            "communication.websocket_manager.websocket_manager.broadcast_state_change",
            side_effect=Exception("State broadcast failed"),
        ):

src/tests/unit/test_demo_mode_comprehensive.py:233:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'communication.websocket_manager.websocket_manager'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'communication' has no attribute 'websocket_manager'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeFSMFailures" name="test_start_fsm_reset_failure" time="0.021" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeFSMFailures" name="test_start_fsm_start_failure" time="0.021" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeFSMFailures" name="test_start_already_running" time="0.121" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeFSMFailures" name="test_stop_fsm_failure" time="0.122" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeFSMFailures" name="test_stop_thread_timeout" time="0.161" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeFSMFailures" name="test_pause_fsm_failure" time="0.131" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeFSMFailures" name="test_pause_already_paused" time="0.129" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeFSMFailures" name="test_resume_fsm_failure" time="0.130" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeFSMFailures" name="test_resume_not_running" time="0.027" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeFSMFailures" name="test_resume_not_paused" time="0.129" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeFSMFailures" name="test_reset_fsm_failure" time="0.032" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeFSMFailures" name="test_reset_while_running" time="0.226" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeCandidatePool" name="test_candidate_pool_activation_in_training" time="0.551" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeCandidatePool" name="test_candidate_pool_clear_on_output_phase" time="0.325" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeCandidatePool" name="test_should_add_cascade_unit_max_reached" time="0.049" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeCandidatePool" name="test_should_add_cascade_unit_not_interval" time="0.026" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeCandidatePool" name="test_should_add_cascade_unit_at_interval" time="0.060" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeTrainingLoop" name="test_training_loop_max_epochs" time="0.521" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeTrainingLoop" name="test_training_loop_stop_during_pause" time="0.347" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeTrainingLoop" name="test_update_training_state_without_training_state" time="0.042" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeTrainingLoop" name="test_broadcast_state_without_training_state" time="0.023" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeTrainingLoop" name="test_simulate_candidate_pool_without_pool" time="0.022" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeApplyParams" name="test_apply_learning_rate" time="0.024" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeApplyParams" name="test_apply_max_hidden_units" time="0.022" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeApplyParams" name="test_apply_max_epochs" time="0.022" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeApplyParams" name="test_apply_all_params" time="0.021" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeApplyParams" name="test_apply_params_none_values" time="0.025" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModePauseResumeEdgeCases" name="test_pause_saves_candidate_state" time="0.328" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModePauseResumeEdgeCases" name="test_resume_restores_candidate_state" time="0.328" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeGetMethods" name="test_get_network" time="0.045" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeGetMethods" name="test_get_dataset" time="0.022" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeGetMethods" name="test_get_metrics_history_thread_safe" time="0.223" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeGetMethods" name="test_get_current_state_all_fields" time="0.021" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeUpdateTrainingState" name="test_update_training_state_with_status" time="0.023" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModeUpdateTrainingState" name="test_update_training_state_no_status" time="0.021" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModePerformReset" name="test_perform_reset" time="0.124" /><testcase classname="src.tests.unit.test_demo_mode_comprehensive.TestDemoModePerformReset" name="test_reset_state_and_history" time="0.222" /><testcase classname="src.tests.unit.test_logger_coverage.TestCascorLoggerBasics" name="test_logger_initialization" time="0.003" /><testcase classname="src.tests.unit.test_logger_coverage.TestCascorLoggerBasics" name="test_logger_default_levels" time="0.003" /><testcase classname="src.tests.unit.test_logger_coverage.TestCascorLoggerBasics" name="test_logger_custom_levels" time="0.003" /><testcase classname="src.tests.unit.test_logger_coverage.TestLoggingLevels" name="test_debug_logging" time="0.003" /><testcase classname="src.tests.unit.test_logger_coverage.TestLoggingLevels" name="test_info_logging" time="0.003" /><testcase classname="src.tests.unit.test_logger_coverage.TestLoggingLevels" name="test_warning_logging" time="0.003" /><testcase classname="src.tests.unit.test_logger_coverage.TestLoggingLevels" name="test_error_logging" time="0.005" /><testcase classname="src.tests.unit.test_logger_coverage.TestLoggingLevels" name="test_critical_logging" time="0.004" /><testcase classname="src.tests.unit.test_logger_coverage.TestLoggingLevels" name="test_fatal_logging" time="0.004" /><testcase classname="src.tests.unit.test_logger_coverage.TestLoggingLevels" name="test_verbose_logging" time="0.000"><skipped type="pytest.skip" message="VERBOSE is custom level, not in standard logging module">/home/pcalnon/Development/python/Juniper/JuniperCanopy/juniper_canopy/src/tests/unit/test_logger_coverage.py:134: VERBOSE is custom level, not in standard logging module</skipped></testcase><testcase classname="src.tests.unit.test_logger_coverage.TestLoggingLevels" name="test_trace_logging" time="0.002" /><testcase classname="src.tests.unit.test_logger_coverage.TestErrorLoggingWithException" name="test_error_with_exception" time="0.001" /><testcase classname="src.tests.unit.test_logger_coverage.TestErrorLoggingWithException" name="test_error_without_exception" time="0.002" /><testcase classname="src.tests.unit.test_logger_coverage.TestFileHandlers" name="test_file_handler_creates_log_file" time="0.002" /><testcase classname="src.tests.unit.test_logger_coverage.TestFileHandlers" name="test_log_rotation_config" time="0.001" /><testcase classname="src.tests.unit.test_logger_coverage.TestNoDuplicateHandlers" name="test_no_duplicate_handlers_on_reinitialization" time="0.001" /><testcase classname="src.tests.unit.test_logger_coverage.TestColoredFormatter" name="test_colored_formatter_formats_record" time="0.001" /><testcase classname="src.tests.unit.test_logger_coverage.TestColoredFormatter" name="test_colored_formatter_all_levels" time="0.001" /><testcase classname="src.tests.unit.test_logger_coverage.TestJsonFormatter" name="test_json_formatter_creates_json" time="0.002" /><testcase classname="src.tests.unit.test_logger_coverage.TestJsonFormatter" name="test_json_formatter_includes_context" time="0.001" /><testcase classname="src.tests.unit.test_logger_coverage.TestTimestampFormat" name="test_timestamp_in_log_message" time="0.002" /><testcase classname="src.tests.unit.test_logger_coverage.TestTrainingLogger" name="test_training_logger_initialization" time="0.001" /><testcase classname="src.tests.unit.test_logger_coverage.TestTrainingLogger" name="test_log_epoch_start" time="0.002" /><testcase classname="src.tests.unit.test_logger_coverage.TestTrainingLogger" name="test_log_epoch_metrics" time="0.003" /><testcase classname="src.tests.unit.test_logger_coverage.TestTrainingLogger" name="test_log_cascade_event" time="0.002" /><testcase classname="src.tests.unit.test_logger_coverage.TestTrainingLogger" name="test_log_network_topology_change" time="0.001" /><testcase classname="src.tests.unit.test_logger_coverage.TestUILogger" name="test_ui_logger_initialization" time="0.002" /><testcase classname="src.tests.unit.test_logger_coverage.TestUILogger" name="test_log_user_action" time="0.059" /><testcase classname="src.tests.unit.test_logger_coverage.TestUILogger" name="test_log_configuration_change" time="0.002" /><testcase classname="src.tests.unit.test_logger_coverage.TestUILogger" name="test_log_visualization_update" time="0.002" /><testcase classname="src.tests.unit.test_logger_coverage.TestSystemLogger" name="test_system_logger_initialization" time="0.001" /><testcase classname="src.tests.unit.test_logger_coverage.TestSystemLogger" name="test_log_startup_sequence" time="0.002" /><testcase classname="src.tests.unit.test_logger_coverage.TestSystemLogger" name="test_log_performance_metrics" time="0.002" /><testcase classname="src.tests.unit.test_logger_coverage.TestSystemLogger" name="test_log_websocket_connection" time="0.002" /><testcase classname="src.tests.unit.test_logger_coverage.TestSystemLogger" name="test_log_system_resource_usage" time="0.001" /><testcase classname="src.tests.unit.test_logger_coverage.TestPerformanceLogger" name="test_time_operation_success" time="0.001" /><testcase classname="src.tests.unit.test_logger_coverage.TestPerformanceLogger" name="test_time_operation_failure" time="0.003" /><testcase classname="src.tests.unit.test_logger_coverage.TestPerformanceLogger" name="test_log_memory_usage" time="0.002" /><testcase classname="src.tests.unit.test_logger_coverage.TestLoggingConfig" name="test_logging_config_loads_defaults" time="0.001" /><testcase classname="src.tests.unit.test_logger_coverage.TestLoggingConfig" name="test_get_logger_config" time="0.001" /><testcase classname="src.tests.unit.test_logger_coverage.TestLoggerFactory" name="test_get_training_logger" time="0.004" /><testcase classname="src.tests.unit.test_logger_coverage.TestLoggerFactory" name="test_get_ui_logger" time="0.004" /><testcase classname="src.tests.unit.test_logger_coverage.TestLoggerFactory" name="test_get_system_logger" time="0.004" /><testcase classname="src.tests.unit.test_logger_coverage.TestLoggerFactory" name="test_get_custom_logger" time="0.004" /><testcase classname="src.tests.unit.test_logger_coverage.TestConvenienceFunctions" name="test_get_training_logger_function" time="0.001" /><testcase classname="src.tests.unit.test_logger_coverage.TestConvenienceFunctions" name="test_get_ui_logger_function" time="0.001" /><testcase classname="src.tests.unit.test_logger_coverage.TestConvenienceFunctions" name="test_get_system_logger_function" time="0.001" /><testcase classname="src.tests.unit.test_logger_coverage.TestConvenienceFunctions" name="test_get_logger_function" time="0.001" /><testcase classname="src.tests.unit.test_logger_coverage.TestContextManager" name="test_logging_context" time="0.001" /><testcase classname="src.tests.unit.test_main_api_coverage.TestScheduleBroadcast" name="test_schedule_broadcast_loop_is_none_logs_warning" time="0.002"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_api_coverage.TestScheduleBroadcast object at 0x7b0bd3beefd0&gt;

    def test_schedule_broadcast_loop_is_none_logs_warning(self):
        """When loop_holder['loop'] is None, should log warning."""
&gt;       import main

src/tests/unit/test_main_api_coverage.py:44:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestScheduleBroadcast" name="test_schedule_broadcast_loop_is_closed_logs_warning" time="0.002"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_api_coverage.TestScheduleBroadcast object at 0x7b0bd3bef110&gt;

    def test_schedule_broadcast_loop_is_closed_logs_warning(self):
        """When loop_holder['loop'] is closed, should log warning."""
&gt;       import main

src/tests/unit/test_main_api_coverage.py:61:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestScheduleBroadcast" name="test_schedule_broadcast_loop_open_calls_run_coroutine_threadsafe" time="0.003"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_api_coverage.TestScheduleBroadcast object at 0x7b0bd3b66650&gt;

    def test_schedule_broadcast_loop_open_calls_run_coroutine_threadsafe(self):
        """When loop is open, should call run_coroutine_threadsafe."""
&gt;       import main

src/tests/unit/test_main_api_coverage.py:80:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestScheduleBroadcast" name="test_schedule_broadcast_exception_logs_error" time="0.002"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_api_coverage.TestScheduleBroadcast object at 0x7b0bd3b66780&gt;

    def test_schedule_broadcast_exception_logs_error(self):
        """When run_coroutine_threadsafe raises, should log error."""
&gt;       import main

src/tests/unit/test_main_api_coverage.py:100:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestTopologyEndpointDirect" name="test_topology_cascor_mode_returns_topology" time="0.001"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestTopologyEndpointDirect" name="test_topology_cascor_mode_no_topology_returns_503" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestTopologyEndpointDirect" name="test_topology_no_backend_returns_503" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestDatasetEndpointDirect" name="test_dataset_cascor_mode_returns_data" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestDatasetEndpointDirect" name="test_dataset_cascor_mode_no_data_returns_503" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestDatasetEndpointDirect" name="test_dataset_no_backend_returns_503" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestDecisionBoundaryEndpointDirect" name="test_decision_boundary_cascor_mode_with_predict_fn" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestDecisionBoundaryEndpointDirect" name="test_decision_boundary_no_backend_returns_503" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestTrainingControlEndpointsDirect" name="test_train_start_demo_mode_returns_started" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestTrainingControlEndpointsDirect" name="test_train_start_cascor_mode_returns_unimplemented" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestTrainingControlEndpointsDirect" name="test_train_start_no_backend_returns_503" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestTrainingControlEndpointsDirect" name="test_train_pause_demo_mode_returns_paused" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestTrainingControlEndpointsDirect" name="test_train_pause_no_backend_returns_503" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestTrainingControlEndpointsDirect" name="test_train_resume_demo_mode_returns_running" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestTrainingControlEndpointsDirect" name="test_train_resume_no_backend_returns_503" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestTrainingControlEndpointsDirect" name="test_train_stop_demo_mode_returns_stopped" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestTrainingControlEndpointsDirect" name="test_train_stop_no_backend_returns_503" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestTrainingControlEndpointsDirect" name="test_train_reset_demo_mode_returns_reset_state" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestTrainingControlEndpointsDirect" name="test_train_reset_no_backend_returns_503" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestMetricsHistoryEndpointDirect" name="test_metrics_history_cascor_mode_returns_history" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestMetricsHistoryEndpointDirect" name="test_metrics_history_no_backend_returns_503" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestMetricsEndpointDirect" name="test_metrics_cascor_mode_with_to_dict" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestMetricsEndpointDirect" name="test_metrics_cascor_mode_without_to_dict" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestMetricsEndpointDirect" name="test_metrics_no_backend_returns_empty" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestStatusEndpointDirect" name="test_status_cascor_mode_returns_training_status" time="0.001"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestStatusEndpointDirect" name="test_status_no_backend_returns_inactive" time="0.001"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestNetworkStatsEndpointDirect" name="test_network_stats_cascor_mode_returns_stats" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestNetworkStatsEndpointDirect" name="test_network_stats_no_backend_returns_503" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestHealthEndpointDirect" name="test_health_cascor_mode_with_training_monitor" time="0.001"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestHealthEndpointDirect" name="test_health_no_backend_returns_inactive" time="0.001"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestStateEndpointDirect" name="test_state_without_demo_mode_uses_global_training_state" time="0.001"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_api_coverage.TestStateEndpointDirect" name="test_state_with_demo_mode_uses_demo_training_state" time="0.001"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestCascorBackendModeStartup" name="test_cascor_backend_mode_log_message" time="0.006"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_coverage_extended.TestCascorBackendModeStartup object at 0x7b0cfc120f50&gt;

    @pytest.mark.unit
    def test_cascor_backend_mode_log_message(self):
        """Test CasCor backend mode log message is generated."""
        with patch.dict(os.environ, {"CASCOR_DEMO_MODE": "0"}):
&gt;           with patch("main.CascorIntegration") as mock_cascor:
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/tests/unit/test_main_coverage_extended.py:52:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:458: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestCascorBackendModeStartup" name="test_cascor_integration_setup_with_backend" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">self = &lt;src.tests.unit.test_main_coverage_extended.TestCascorBackendModeStartup object at 0x7b0cfc121090&gt;

    @pytest.mark.unit
    def test_cascor_integration_setup_with_backend(self):
        """Test cascor_integration is set when backend available."""
        mock_integration = MagicMock()
&gt;       with patch("backend.cascor_integration.CascorIntegration", return_value=mock_integration):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/tests/unit/test_main_coverage_extended.py:62:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestCascorInitializationExceptions" name="test_file_not_found_fallback_to_demo_mode" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">self = &lt;src.tests.unit.test_main_coverage_extended.TestCascorInitializationExceptions object at 0x7b0cfc121310&gt;

    @pytest.mark.unit
    def test_file_not_found_fallback_to_demo_mode(self):
        """Test FileNotFoundError triggers demo mode fallback."""
&gt;       with patch("backend.cascor_integration.CascorIntegration") as mock_cascor:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/tests/unit/test_main_coverage_extended.py:75:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestCascorInitializationExceptions" name="test_generic_exception_fallback_to_demo_mode" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">self = &lt;src.tests.unit.test_main_coverage_extended.TestCascorInitializationExceptions object at 0x7b0cfc121450&gt;

    @pytest.mark.unit
    def test_generic_exception_fallback_to_demo_mode(self):
        """Test generic Exception triggers demo mode fallback."""
&gt;       with patch("backend.cascor_integration.CascorIntegration") as mock_cascor:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/tests/unit/test_main_coverage_extended.py:85:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestSetupMonitoringCallbacks" name="test_on_metrics_update_callback" time="0.003"><failure message="ModuleNotFoundError: No module named 'fastapi'">self = &lt;src.tests.unit.test_main_coverage_extended.TestSetupMonitoringCallbacks object at 0x7b0cfc121e50&gt;

    @pytest.mark.unit
    def test_on_metrics_update_callback(self):
        """Test on_metrics_update callback processes metrics."""
&gt;       from communication.websocket_manager import create_metrics_message

src/tests/unit/test_main_coverage_extended.py:99:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     websocket_manager.py
    # Author:        Paul Calnon
    # Version:       2.0.0
    #
    # Date:          2025-10-11
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module manages WebSocket connections for real-time communication between
    #    the backend training system and frontend dashboard. Includes standardized
    #    message schema and builder functions.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # WebSocket Manager Module
    #
    # Manages WebSocket connections for real-time communication between
    # the backend training system and frontend dashboard.
    #
    # Features:
    # - Connection management (connect, disconnect, track metadata)
    # - Broadcasting messages to all connected clients
    # - Synchronous broadcasting for non-async code
    # - Connection health monitoring
    # - Automatic cleanup of broken connections
    # - Standardized message schema
    #
    # WebSocket Message Schema:
    # All messages follow this format:
    # {
    #     "type": "state | metrics | topology | event | control_ack",
    #     "timestamp": &lt;float&gt;,  # Unix timestamp with milliseconds
    #     "data": {
    #         # Type-specific payload
    #     }
    # }
    #
    # Message Types:
    # - state: Training state updates (status, phase, learning_rate, etc.)
    # - metrics: Training metrics (loss, accuracy, validation metrics)
    # - topology: Network topology changes (nodes, connections, architecture)
    # - event: Training events (cascade_add, phase_change, etc.)
    # - control_ack: Control command acknowledgments
    #
    # Example Messages:
    #
    # State Message:
    # {
    #     "type": "state",
    #     "timestamp": 1700000000.123,
    #     "data": {
    #         "status": "Started",
    #         "phase": "Output",
    #         "learning_rate": 0.01,
    #         "current_epoch": 42,
    #         ...
    #     }
    # }
    #
    # Metrics Message:
    # {
    #     "type": "metrics",
    #     "timestamp": 1700000000.456,
    #     "data": {
    #         "epoch": 42,
    #         "metrics": {
    #             "loss": 0.23,
    #             "accuracy": 0.91,
    #             "val_loss": 0.25,
    #             "val_accuracy": 0.89
    #         }
    #     }
    # }
    #
    # Topology Message:
    # {
    #     "type": "topology",
    #     "timestamp": 1700000000.789,
    #     "data": {
    #         "input_units": 2,
    #         "hidden_units": 3,
    #         "output_units": 1,
    #         "nodes": [...],
    #         "connections": [...]
    #     }
    # }
    #
    # Event Message:
    # {
    #     "type": "event",
    #     "timestamp": 1700000000.999,
    #     "data": {
    #         "event_type": "cascade_add",
    #         "details": {
    #             "unit_index": 2,
    #             "total_hidden_units": 3,
    #             "epoch": 42
    #         }
    #     }
    # }
    #
    # Control Acknowledgment Message:
    # {
    #     "type": "control_ack",
    #     "timestamp": 1700000001.123,
    #     "data": {
    #         "command": "start",
    #         "success": true,
    #         "message": "Training started successfully"
    #     }
    # }
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import contextlib

    # import json
    import logging
    import time
    from datetime import datetime

    # from typing import Set, Dict, Any, Optional
    from typing import Any, Dict, Optional, Set

    # from fastapi import WebSocket, WebSocketDisconnect
&gt;   from fastapi import WebSocket
E   ModuleNotFoundError: No module named 'fastapi'

src/communication/websocket_manager.py:143: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestSetupMonitoringCallbacks" name="test_on_topology_change_callback" time="0.002"><failure message="ModuleNotFoundError: No module named 'fastapi'">self = &lt;src.tests.unit.test_main_coverage_extended.TestSetupMonitoringCallbacks object at 0x7b0cfc121f90&gt;

    @pytest.mark.unit
    def test_on_topology_change_callback(self):
        """Test on_topology_change callback processes topology."""
&gt;       from communication.websocket_manager import create_topology_message

src/tests/unit/test_main_coverage_extended.py:111:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     websocket_manager.py
    # Author:        Paul Calnon
    # Version:       2.0.0
    #
    # Date:          2025-10-11
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module manages WebSocket connections for real-time communication between
    #    the backend training system and frontend dashboard. Includes standardized
    #    message schema and builder functions.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # WebSocket Manager Module
    #
    # Manages WebSocket connections for real-time communication between
    # the backend training system and frontend dashboard.
    #
    # Features:
    # - Connection management (connect, disconnect, track metadata)
    # - Broadcasting messages to all connected clients
    # - Synchronous broadcasting for non-async code
    # - Connection health monitoring
    # - Automatic cleanup of broken connections
    # - Standardized message schema
    #
    # WebSocket Message Schema:
    # All messages follow this format:
    # {
    #     "type": "state | metrics | topology | event | control_ack",
    #     "timestamp": &lt;float&gt;,  # Unix timestamp with milliseconds
    #     "data": {
    #         # Type-specific payload
    #     }
    # }
    #
    # Message Types:
    # - state: Training state updates (status, phase, learning_rate, etc.)
    # - metrics: Training metrics (loss, accuracy, validation metrics)
    # - topology: Network topology changes (nodes, connections, architecture)
    # - event: Training events (cascade_add, phase_change, etc.)
    # - control_ack: Control command acknowledgments
    #
    # Example Messages:
    #
    # State Message:
    # {
    #     "type": "state",
    #     "timestamp": 1700000000.123,
    #     "data": {
    #         "status": "Started",
    #         "phase": "Output",
    #         "learning_rate": 0.01,
    #         "current_epoch": 42,
    #         ...
    #     }
    # }
    #
    # Metrics Message:
    # {
    #     "type": "metrics",
    #     "timestamp": 1700000000.456,
    #     "data": {
    #         "epoch": 42,
    #         "metrics": {
    #             "loss": 0.23,
    #             "accuracy": 0.91,
    #             "val_loss": 0.25,
    #             "val_accuracy": 0.89
    #         }
    #     }
    # }
    #
    # Topology Message:
    # {
    #     "type": "topology",
    #     "timestamp": 1700000000.789,
    #     "data": {
    #         "input_units": 2,
    #         "hidden_units": 3,
    #         "output_units": 1,
    #         "nodes": [...],
    #         "connections": [...]
    #     }
    # }
    #
    # Event Message:
    # {
    #     "type": "event",
    #     "timestamp": 1700000000.999,
    #     "data": {
    #         "event_type": "cascade_add",
    #         "details": {
    #             "unit_index": 2,
    #             "total_hidden_units": 3,
    #             "epoch": 42
    #         }
    #     }
    # }
    #
    # Control Acknowledgment Message:
    # {
    #     "type": "control_ack",
    #     "timestamp": 1700000001.123,
    #     "data": {
    #         "command": "start",
    #         "success": true,
    #         "message": "Training started successfully"
    #     }
    # }
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import contextlib

    # import json
    import logging
    import time
    from datetime import datetime

    # from typing import Set, Dict, Any, Optional
    from typing import Any, Dict, Optional, Set

    # from fastapi import WebSocket, WebSocketDisconnect
&gt;   from fastapi import WebSocket
E   ModuleNotFoundError: No module named 'fastapi'

src/communication/websocket_manager.py:143: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestSetupMonitoringCallbacks" name="test_on_cascade_add_callback" time="0.002"><failure message="ModuleNotFoundError: No module named 'fastapi'">self = &lt;src.tests.unit.test_main_coverage_extended.TestSetupMonitoringCallbacks object at 0x7b0cfc194180&gt;

    @pytest.mark.unit
    def test_on_cascade_add_callback(self):
        """Test on_cascade_add callback processes events."""
&gt;       from communication.websocket_manager import create_event_message

src/tests/unit/test_main_coverage_extended.py:122:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     websocket_manager.py
    # Author:        Paul Calnon
    # Version:       2.0.0
    #
    # Date:          2025-10-11
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module manages WebSocket connections for real-time communication between
    #    the backend training system and frontend dashboard. Includes standardized
    #    message schema and builder functions.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # WebSocket Manager Module
    #
    # Manages WebSocket connections for real-time communication between
    # the backend training system and frontend dashboard.
    #
    # Features:
    # - Connection management (connect, disconnect, track metadata)
    # - Broadcasting messages to all connected clients
    # - Synchronous broadcasting for non-async code
    # - Connection health monitoring
    # - Automatic cleanup of broken connections
    # - Standardized message schema
    #
    # WebSocket Message Schema:
    # All messages follow this format:
    # {
    #     "type": "state | metrics | topology | event | control_ack",
    #     "timestamp": &lt;float&gt;,  # Unix timestamp with milliseconds
    #     "data": {
    #         # Type-specific payload
    #     }
    # }
    #
    # Message Types:
    # - state: Training state updates (status, phase, learning_rate, etc.)
    # - metrics: Training metrics (loss, accuracy, validation metrics)
    # - topology: Network topology changes (nodes, connections, architecture)
    # - event: Training events (cascade_add, phase_change, etc.)
    # - control_ack: Control command acknowledgments
    #
    # Example Messages:
    #
    # State Message:
    # {
    #     "type": "state",
    #     "timestamp": 1700000000.123,
    #     "data": {
    #         "status": "Started",
    #         "phase": "Output",
    #         "learning_rate": 0.01,
    #         "current_epoch": 42,
    #         ...
    #     }
    # }
    #
    # Metrics Message:
    # {
    #     "type": "metrics",
    #     "timestamp": 1700000000.456,
    #     "data": {
    #         "epoch": 42,
    #         "metrics": {
    #             "loss": 0.23,
    #             "accuracy": 0.91,
    #             "val_loss": 0.25,
    #             "val_accuracy": 0.89
    #         }
    #     }
    # }
    #
    # Topology Message:
    # {
    #     "type": "topology",
    #     "timestamp": 1700000000.789,
    #     "data": {
    #         "input_units": 2,
    #         "hidden_units": 3,
    #         "output_units": 1,
    #         "nodes": [...],
    #         "connections": [...]
    #     }
    # }
    #
    # Event Message:
    # {
    #     "type": "event",
    #     "timestamp": 1700000000.999,
    #     "data": {
    #         "event_type": "cascade_add",
    #         "details": {
    #             "unit_index": 2,
    #             "total_hidden_units": 3,
    #             "epoch": 42
    #         }
    #     }
    # }
    #
    # Control Acknowledgment Message:
    # {
    #     "type": "control_ack",
    #     "timestamp": 1700000001.123,
    #     "data": {
    #         "command": "start",
    #         "success": true,
    #         "message": "Training started successfully"
    #     }
    # }
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import contextlib

    # import json
    import logging
    import time
    from datetime import datetime

    # from typing import Set, Dict, Any, Optional
    from typing import Any, Dict, Optional, Set

    # from fastapi import WebSocket, WebSocketDisconnect
&gt;   from fastapi import WebSocket
E   ModuleNotFoundError: No module named 'fastapi'

src/communication/websocket_manager.py:143: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestSetupMonitoringCallbacks" name="test_metrics_with_to_dict_method" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestWebSocketTrainingEndpoint" name="test_websocket_training_connects" time="0.001"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestWebSocketTrainingEndpoint" name="test_websocket_training_ping_pong" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestWebSocketTrainingEndpoint" name="test_websocket_training_unknown_message_type" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestWebSocketControlEndpoint" name="test_websocket_control_start_command" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestWebSocketControlEndpoint" name="test_websocket_control_stop_command" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestWebSocketControlEndpoint" name="test_websocket_control_pause_command" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestWebSocketControlEndpoint" name="test_websocket_control_resume_command" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestWebSocketControlEndpoint" name="test_websocket_control_reset_command" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestWebSocketControlEndpoint" name="test_websocket_control_unknown_command" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestCommandExecutionError" name="test_command_execution_catches_exception" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestHiddenUnitTopologyConnections" name="test_topology_with_hidden_units" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestHiddenUnitTopologyConnections" name="test_topology_hidden_to_output_connections" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestHiddenUnitTopologyConnections" name="test_topology_input_to_hidden_connections" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestHiddenUnitTopologyConnections" name="test_topology_hidden_to_hidden_cascade_connections" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestWebSocketDisconnectHandler" name="test_ws_endpoint_disconnect" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestWebSocketDisconnectHandler" name="test_training_websocket_disconnect" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestSetParamsExceptionHandling" name="test_set_params_empty_body_returns_400" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestSetParamsExceptionHandling" name="test_set_params_invalid_json_body" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestSetParamsExceptionHandling" name="test_set_params_with_valid_params_succeeds" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestMainFunction" name="test_main_function_exists" time="0.003"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_coverage_extended.TestMainFunction object at 0x7b0cfc122e90&gt;

    @pytest.mark.unit
    def test_main_function_exists(self):
        """Test main function is defined."""
&gt;       from main import main

src/tests/unit/test_main_coverage_extended.py:333:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestMainFunction" name="test_main_uses_config_hierarchy" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestMainFunction" name="test_main_env_host_override" time="0.007" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestMainFunction" name="test_main_env_port_override" time="0.006" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestMainFunction" name="test_main_env_debug_override_true" time="0.006" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestMainFunction" name="test_main_env_debug_override_false" time="0.006" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestMainFunction" name="test_main_with_uvicorn_run_mocked" time="0.002"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_coverage_extended.TestMainFunction object at 0x7b0bd3bd3790&gt;

    @pytest.mark.unit
    def test_main_with_uvicorn_run_mocked(self):
        """Test main() calls uvicorn.run."""
&gt;       with patch("main.uvicorn.run") as mock_run:
             ^^^^^^^^^^^^^^^^^^^^^^^^^

src/tests/unit/test_main_coverage_extended.py:379:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:458: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestMainFunction" name="test_main_config_source_logging" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestScheduleBroadcast" name="test_schedule_broadcast_callable" time="0.002"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_coverage_extended.TestScheduleBroadcast object at 0x7b0cfc123110&gt;

    @pytest.mark.unit
    def test_schedule_broadcast_callable(self):
        """Test schedule_broadcast is callable."""
&gt;       from main import schedule_broadcast

src/tests/unit/test_main_coverage_extended.py:404:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestScheduleBroadcast" name="test_schedule_broadcast_with_coroutine" time="0.003"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_coverage_extended.TestScheduleBroadcast object at 0x7b0cfc123250&gt;

    @pytest.mark.unit
    def test_schedule_broadcast_with_coroutine(self):
        """Test schedule_broadcast handles coroutines."""
&gt;       from main import schedule_broadcast

src/tests/unit/test_main_coverage_extended.py:411:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestLifespanShutdown" name="test_websocket_manager_shutdown" time="0.002"><failure message="ModuleNotFoundError: No module named 'fastapi'">self = &lt;src.tests.unit.test_main_coverage_extended.TestLifespanShutdown object at 0x7b0cfc123390&gt;

    @pytest.mark.unit
    def test_websocket_manager_shutdown(self):
        """Test websocket_manager.shutdown is async."""
&gt;       from communication.websocket_manager import websocket_manager

src/tests/unit/test_main_coverage_extended.py:431:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     websocket_manager.py
    # Author:        Paul Calnon
    # Version:       2.0.0
    #
    # Date:          2025-10-11
    # Last Modified: 2025-12-03
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This module manages WebSocket connections for real-time communication between
    #    the backend training system and frontend dashboard. Includes standardized
    #    message schema and builder functions.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # WebSocket Manager Module
    #
    # Manages WebSocket connections for real-time communication between
    # the backend training system and frontend dashboard.
    #
    # Features:
    # - Connection management (connect, disconnect, track metadata)
    # - Broadcasting messages to all connected clients
    # - Synchronous broadcasting for non-async code
    # - Connection health monitoring
    # - Automatic cleanup of broken connections
    # - Standardized message schema
    #
    # WebSocket Message Schema:
    # All messages follow this format:
    # {
    #     "type": "state | metrics | topology | event | control_ack",
    #     "timestamp": &lt;float&gt;,  # Unix timestamp with milliseconds
    #     "data": {
    #         # Type-specific payload
    #     }
    # }
    #
    # Message Types:
    # - state: Training state updates (status, phase, learning_rate, etc.)
    # - metrics: Training metrics (loss, accuracy, validation metrics)
    # - topology: Network topology changes (nodes, connections, architecture)
    # - event: Training events (cascade_add, phase_change, etc.)
    # - control_ack: Control command acknowledgments
    #
    # Example Messages:
    #
    # State Message:
    # {
    #     "type": "state",
    #     "timestamp": 1700000000.123,
    #     "data": {
    #         "status": "Started",
    #         "phase": "Output",
    #         "learning_rate": 0.01,
    #         "current_epoch": 42,
    #         ...
    #     }
    # }
    #
    # Metrics Message:
    # {
    #     "type": "metrics",
    #     "timestamp": 1700000000.456,
    #     "data": {
    #         "epoch": 42,
    #         "metrics": {
    #             "loss": 0.23,
    #             "accuracy": 0.91,
    #             "val_loss": 0.25,
    #             "val_accuracy": 0.89
    #         }
    #     }
    # }
    #
    # Topology Message:
    # {
    #     "type": "topology",
    #     "timestamp": 1700000000.789,
    #     "data": {
    #         "input_units": 2,
    #         "hidden_units": 3,
    #         "output_units": 1,
    #         "nodes": [...],
    #         "connections": [...]
    #     }
    # }
    #
    # Event Message:
    # {
    #     "type": "event",
    #     "timestamp": 1700000000.999,
    #     "data": {
    #         "event_type": "cascade_add",
    #         "details": {
    #             "unit_index": 2,
    #             "total_hidden_units": 3,
    #             "epoch": 42
    #         }
    #     }
    # }
    #
    # Control Acknowledgment Message:
    # {
    #     "type": "control_ack",
    #     "timestamp": 1700000001.123,
    #     "data": {
    #         "command": "start",
    #         "success": true,
    #         "message": "Training started successfully"
    #     }
    # }
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import contextlib

    # import json
    import logging
    import time
    from datetime import datetime

    # from typing import Set, Dict, Any, Optional
    from typing import Any, Dict, Optional, Set

    # from fastapi import WebSocket, WebSocketDisconnect
&gt;   from fastapi import WebSocket
E   ModuleNotFoundError: No module named 'fastapi'

src/communication/websocket_manager.py:143: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestCascorIntegrationBranches" name="test_cascor_integration_get_training_status" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestCascorIntegrationBranches" name="test_cascor_integration_shutdown_method" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestNoBackendAvailableBranches" name="test_websocket_control_no_backend_error" time="0.000" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestNoBackendAvailableBranches" name="test_cascor_backend_not_implemented_error" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestWebSocketGenericEndpoint" name="test_ws_endpoint_connects" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestDemoModeInstanceInitialization" name="test_demo_mode_singleton_access" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestAPIEndpointErrorResponses" name="test_json_response_error_format" time="0.001"><failure message="ModuleNotFoundError: No module named 'fastapi'">self = &lt;src.tests.unit.test_main_coverage_extended.TestAPIEndpointErrorResponses object at 0x7b0cfc123c50&gt;

    @pytest.mark.unit
    def test_json_response_error_format(self):
        """Test JSONResponse error format."""
&gt;       from fastapi.responses import JSONResponse
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:506: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestAPIEndpointErrorResponses" name="test_health_check_with_demo_mode" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestNetworkStatisticsEndpoint" name="test_network_stats_returns_statistics" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestNetworkStatisticsEndpoint" name="test_network_stats_includes_weight_stats" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestTrainingStateIntegration" name="test_training_state_machine_get_status" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestTrainingStateIntegration" name="test_training_state_machine_status_enum" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestMonitoringCallbacksInner" name="test_metrics_callback_with_dict_metrics" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestMonitoringCallbacksInner" name="test_topology_callback_with_dict_topology" time="0.000" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestMonitoringCallbacksInner" name="test_cascade_event_with_dict_event" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestMonitoringCallbacksInner" name="test_cascade_event_with_non_dict_event" time="0.000" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestCascorIntegrationCallbackRegistration" name="test_create_monitoring_callback_method" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestCascorIntegrationCallbackRegistration" name="test_register_multiple_callbacks" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestWebSocketExceptionHandling" name="test_websocket_error_logging_path" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestWebSocketExceptionHandling" name="test_websocket_disconnect_handling" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestMainDebugConfigBranch" name="test_debug_config_none_defaults_false" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestMainDebugConfigBranch" name="test_debug_config_true_when_set" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestHiddenUnitConnectionExtraction" name="test_hidden_output_connection_weight_extraction" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestHiddenUnitConnectionExtraction" name="test_input_hidden_connection_weight_extraction" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestHiddenUnitConnectionExtraction" name="test_hidden_hidden_cascade_weight_extraction" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestSetParamsExceptionBranch" name="test_set_params_exception_returns_500" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestSetParamsExceptionBranch" name="test_set_params_value_error_handling" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestModuleLevelInitialization" name="test_force_demo_mode_env_values" time="0.031" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestModuleLevelInitialization" name="test_force_demo_mode_env_false_values" time="0.014" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestCascorIntegrationInitializationPaths" name="test_cascor_file_not_found_exception" time="0.003"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">self = &lt;src.tests.unit.test_main_coverage_extended.TestCascorIntegrationInitializationPaths object at 0x7b0bd3aa1590&gt;

    @pytest.mark.unit
    def test_cascor_file_not_found_exception(self):
        """Test FileNotFoundError during CascorIntegration init."""
&gt;       with patch("backend.cascor_integration.CascorIntegration") as mock_cls:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/tests/unit/test_main_coverage_extended.py:759:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestCascorIntegrationInitializationPaths" name="test_cascor_generic_exception" time="0.002"><failure message="AttributeError: module 'backend' has no attribute 'cascor_integration'">self = &lt;src.tests.unit.test_main_coverage_extended.TestCascorIntegrationInitializationPaths object at 0x7b0bd3aa16d0&gt;

    @pytest.mark.unit
    def test_cascor_generic_exception(self):
        """Test generic Exception during CascorIntegration init."""
&gt;       with patch("backend.cascor_integration.CascorIntegration") as mock_cls:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/tests/unit/test_main_coverage_extended.py:773:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'backend.cascor_integration'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'backend' has no attribute 'cascor_integration'

/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:473: AttributeError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestLifespanStartupBranches" name="test_cascor_backend_mode_startup_logs" time="0.003"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_coverage_extended.TestLifespanStartupBranches object at 0x7b0bd3aa1810&gt;

    @pytest.mark.unit
    def test_cascor_backend_mode_startup_logs(self):
        """Test CasCor backend mode startup logging."""
&gt;       with patch("main.system_logger") as mock_logger:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/tests/unit/test_main_coverage_extended.py:791:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/pkgutil.py:458: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1398: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1371: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1342: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:938: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:759: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:491: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestLifespanStartupBranches" name="test_setup_monitoring_callbacks_called" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestLifespanShutdownBranches" name="test_cascor_integration_shutdown_called" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestMainIfNameMain" name="test_main_function_is_called_when_module_run" time="0.002"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_coverage_extended.TestMainIfNameMain object at 0x7b0bd3aa1bd0&gt;

    @pytest.mark.unit
    def test_main_function_is_called_when_module_run(self):
        """Test main() is the entry point."""
&gt;       from main import main

src/tests/unit/test_main_coverage_extended.py:826:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestMainIfNameMain" name="test_main_module_has_name_check" time="0.002"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_coverage_extended.TestMainIfNameMain object at 0x7b0bd3aa1d10&gt;

    @pytest.mark.unit
    def test_main_module_has_name_check(self):
        """Test module uses if __name__ == '__main__' pattern."""
&gt;       import main

src/tests/unit/test_main_coverage_extended.py:833:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestTopologyWithHiddenUnits" name="test_topology_returns_nodes_and_connections" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestTopologyWithHiddenUnits" name="test_topology_connection_structure" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestDirectSetupMonitoringCallbacks" name="test_setup_monitoring_callbacks_function_exists" time="0.002"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_coverage_extended.TestDirectSetupMonitoringCallbacks object at 0x7b0bd3aa20d0&gt;

    @pytest.mark.unit
    def test_setup_monitoring_callbacks_function_exists(self):
        """setup_monitoring_callbacks should be importable."""
&gt;       from main import setup_monitoring_callbacks

src/tests/unit/test_main_coverage_extended.py:869:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestDirectSetupMonitoringCallbacks" name="test_setup_monitoring_callbacks_with_mock_integration" time="0.002"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_coverage_extended.TestDirectSetupMonitoringCallbacks object at 0x7b0bd3aa2210&gt;

    @pytest.mark.unit
    def test_setup_monitoring_callbacks_with_mock_integration(self):
        """Test calling setup_monitoring_callbacks with mocked integration."""
&gt;       import main

src/tests/unit/test_main_coverage_extended.py:876:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestDirectSetupMonitoringCallbacks" name="test_setup_monitoring_callbacks_captures_on_metrics_update" time="0.003"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_coverage_extended.TestDirectSetupMonitoringCallbacks object at 0x7b0cfc196780&gt;

    @pytest.mark.unit
    def test_setup_monitoring_callbacks_captures_on_metrics_update(self):
        """Test on_metrics_update callback is registered and callable."""
&gt;       import main

src/tests/unit/test_main_coverage_extended.py:891:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestDirectSetupMonitoringCallbacks" name="test_setup_monitoring_callbacks_on_topology_change" time="0.002"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_coverage_extended.TestDirectSetupMonitoringCallbacks object at 0x7b0cfc1968b0&gt;

    @pytest.mark.unit
    def test_setup_monitoring_callbacks_on_topology_change(self):
        """Test on_topology_change callback is registered and callable."""
&gt;       import main

src/tests/unit/test_main_coverage_extended.py:916:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestDirectSetupMonitoringCallbacks" name="test_setup_monitoring_callbacks_on_cascade_add" time="0.002"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_coverage_extended.TestDirectSetupMonitoringCallbacks object at 0x7b0cfc191130&gt;

    @pytest.mark.unit
    def test_setup_monitoring_callbacks_on_cascade_add(self):
        """Test on_cascade_add callback is registered and callable."""
&gt;       import main

src/tests/unit/test_main_coverage_extended.py:941:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestDirectSetupMonitoringCallbacks" name="test_on_metrics_update_with_to_dict_method" time="0.002"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_coverage_extended.TestDirectSetupMonitoringCallbacks object at 0x7b0bd3bd3570&gt;

    @pytest.mark.unit
    def test_on_metrics_update_with_to_dict_method(self):
        """Test on_metrics_update handles objects with to_dict method."""
&gt;       import main

src/tests/unit/test_main_coverage_extended.py:966:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestDirectSetupMonitoringCallbacks" name="test_on_cascade_add_with_non_dict_event" time="0.002"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_coverage_extended.TestDirectSetupMonitoringCallbacks object at 0x7b0bd3bd3460&gt;

    @pytest.mark.unit
    def test_on_cascade_add_with_non_dict_event(self):
        """Test on_cascade_add handles non-dict events."""
&gt;       import main

src/tests/unit/test_main_coverage_extended.py:993:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestWebSocketDisconnectPath" name="test_ws_disconnect_cleanup" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestCascorIntegrationWebSocketBranch" name="test_websocket_initial_status_with_cascor" time="0.002"><failure message="ModuleNotFoundError: No module named 'uvicorn'">self = &lt;src.tests.unit.test_main_coverage_extended.TestCascorIntegrationWebSocketBranch object at 0x7b0bd3aa2490&gt;

    @pytest.mark.unit
    def test_websocket_initial_status_with_cascor(self):
        """Test initial status uses cascor_integration when available."""
&gt;       import main

src/tests/unit/test_main_coverage_extended.py:1030:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Sub-Project:   JuniperCanopy
    # Application:   juniper_canopy
    # Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    #
    # Author:        Paul Calnon
    # Version:       0.8.0
    # File Name:     main.py
    # File Path:     ${HOME}/Development/python/JuniperCanopy/juniper_canopy/src/
    #
    # Date Created:  2025-10-11
    # Last Modified: 2026-01-09
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
    #
    # Description:
    #     This file contains the Main function to monitor the current Cascade Correlation Neural Network prototype
    #     including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #     Main Application Entry Point
    #     FastAPI application with Dash integration for Juniper Canopy monitoring.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #     Force pre-commit checks to run
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import asyncio
    import json
    import os

    # import sys
    import time
    from contextlib import asynccontextmanager

    # import dash
&gt;   import uvicorn
E   ModuleNotFoundError: No module named 'uvicorn'

src/main.py:48: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestControlWebSocketBranches" name="test_control_start_with_reset_true" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestControlWebSocketBranches" name="test_control_command_sequence" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestSetParamsEndpointBranches" name="test_set_params_with_all_params" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestSetParamsEndpointBranches" name="test_set_params_with_only_learning_rate" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestLateInitDemoMode" name="test_late_demo_mode_init_path" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestMainDebugConfigFallback" name="test_debug_fallback_when_env_not_set" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestMainDebugConfigFallback" name="test_debug_uses_config_value" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestWebSocketTrainingStatusBranches" name="test_websocket_training_with_demo_mode" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestWebSocketTrainingStatusBranches" name="test_websocket_training_initial_status_received" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestWebSocketErrorHandling" name="test_websocket_handles_invalid_json_gracefully" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestControlWebSocketLateInit" name="test_control_websocket_initializes_demo_mode" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestControlCommandErrorHandling" name="test_unknown_command_returns_error" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestControlCommandErrorHandling" name="test_command_error_message_format" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestTopologyHiddenUnitConnections" name="test_topology_includes_input_output_connections" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestTopologyHiddenUnitConnections" name="test_topology_weight_is_float" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestSetParamsExceptionPath" name="test_set_params_returns_error_on_exception" time="0.000"><error message="failed on setup with &quot;ModuleNotFoundError: No module named 'fastapi'&quot;">@pytest.fixture(scope="module")
    def app_client():
        """Create test client with demo mode."""
&gt;       from fastapi.testclient import TestClient
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:37: ModuleNotFoundError</error></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestSetParamsExceptionPath" name="test_set_params_error_response_format" time="0.001"><failure message="ModuleNotFoundError: No module named 'fastapi'">self = &lt;src.tests.unit.test_main_coverage_extended.TestSetParamsExceptionPath object at 0x7b0bd3aa39d0&gt;

    @pytest.mark.unit
    def test_set_params_error_response_format(self):
        """Test set_params error response has error key."""
&gt;       from fastapi.responses import JSONResponse
E       ModuleNotFoundError: No module named 'fastapi'

src/tests/unit/test_main_coverage_extended.py:1241: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_main_coverage_extended.TestMainFunctionDebugBranch" name="test_debug_config_none_uses_default_false" time="0.001" /><testcase classname="src.tests.unit.test_main_coverage_extended.TestMainFunctionDebugBranch" name="test_debug_config_explicit_false" time="0.000" /><testcase classname="src.tests.unit.test_phase0_fixes.TestTrainingStatusEnumP08" name="test_training_status_has_completed" time="0.000" /><testcase classname="src.tests.unit.test_phase0_fixes.TestTrainingStatusEnumP08" name="test_training_status_has_failed" time="0.000" /><testcase classname="src.tests.unit.test_phase0_fixes.TestStateMachineCompletionP08" name="test_mark_completed_from_started" time="0.001" /><testcase classname="src.tests.unit.test_phase0_fixes.TestStateMachineCompletionP08" name="test_mark_completed_from_stopped_fails" time="0.001" /><testcase classname="src.tests.unit.test_phase0_fixes.TestStateMachineCompletionP08" name="test_mark_completed_from_paused_fails" time="0.001" /><testcase classname="src.tests.unit.test_phase0_fixes.TestStateMachineCompletionP08" name="test_mark_failed_from_started" time="0.001" /><testcase classname="src.tests.unit.test_phase0_fixes.TestStateMachineCompletionP08" name="test_mark_failed_from_paused" time="0.001" /><testcase classname="src.tests.unit.test_phase0_fixes.TestStateMachineCompletionP08" name="test_mark_failed_from_stopped_fails" time="0.001" /><testcase classname="src.tests.unit.test_phase0_fixes.TestStateMachineCompletionP08" name="test_completed_clears_candidate_state" time="0.001" /><testcase classname="src.tests.unit.test_phase0_fixes.TestStateMachineCompletionP08" name="test_failed_clears_candidate_state" time="0.001" /><testcase classname="src.tests.unit.test_phase0_fixes.TestStateMachineCompletionP08" name="test_state_summary_includes_completed" time="0.001" /><testcase classname="src.tests.unit.test_phase0_fixes.TestStateMachineCompletionP08" name="test_state_summary_includes_failed" time="0.001" /><testcase classname="src.tests.unit.test_phase0_fixes.TestStatusBarCompletedFailedP08" name="test_status_bar_shows_completed_when_complete" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash'">self = &lt;src.tests.unit.test_phase0_fixes.TestStatusBarCompletedFailedP08 object at 0x7b0bd3b22d50&gt;

    def test_status_bar_shows_completed_when_complete(self):
        """Status bar should display 'Completed' when training finishes successfully."""
        from unittest.mock import Mock

&gt;       from frontend.dashboard_manager import DashboardManager

src/tests/unit/test_phase0_fixes.py:137:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     dashboard_manager.py
    # Author:        Paul Calnon
    # Version:       0.2.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #     Dashboard Manager Module
    #
    #     Central coordination hub for all frontend components, managing layout,
    #     routing, and component lifecycle.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################

    import logging
    import os
    import time
    from typing import Any, Dict, List
    from urllib.parse import urljoin

&gt;   import dash
E   ModuleNotFoundError: No module named 'dash'

src/frontend/dashboard_manager.py:42: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_phase0_fixes.TestStatusBarCompletedFailedP08" name="test_status_bar_shows_failed_when_failed" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash'">self = &lt;src.tests.unit.test_phase0_fixes.TestStatusBarCompletedFailedP08 object at 0x7b0bd3b22e90&gt;

    def test_status_bar_shows_failed_when_failed(self):
        """Status bar should display 'Failed' when training fails."""
        from unittest.mock import Mock

&gt;       from frontend.dashboard_manager import DashboardManager

src/tests/unit/test_phase0_fixes.py:161:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     dashboard_manager.py
    # Author:        Paul Calnon
    # Version:       0.2.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #     Dashboard Manager Module
    #
    #     Central coordination hub for all frontend components, managing layout,
    #     routing, and component lifecycle.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################

    import logging
    import os
    import time
    from typing import Any, Dict, List
    from urllib.parse import urljoin

&gt;   import dash
E   ModuleNotFoundError: No module named 'dash'

src/frontend/dashboard_manager.py:42: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_phase0_fixes.TestStatusBarCompletedFailedP08" name="test_status_bar_completed_color" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash'">self = &lt;src.tests.unit.test_phase0_fixes.TestStatusBarCompletedFailedP08 object at 0x7b0bd37e02b0&gt;

    def test_status_bar_completed_color(self):
        """Completed status should use cyan color."""
        from unittest.mock import Mock

&gt;       from frontend.dashboard_manager import DashboardManager

src/tests/unit/test_phase0_fixes.py:185:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     dashboard_manager.py
    # Author:        Paul Calnon
    # Version:       0.2.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #     Dashboard Manager Module
    #
    #     Central coordination hub for all frontend components, managing layout,
    #     routing, and component lifecycle.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################

    import logging
    import os
    import time
    from typing import Any, Dict, List
    from urllib.parse import urljoin

&gt;   import dash
E   ModuleNotFoundError: No module named 'dash'

src/frontend/dashboard_manager.py:42: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_phase0_fixes.TestStatusBarCompletedFailedP08" name="test_status_bar_failed_color" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash'">self = &lt;src.tests.unit.test_phase0_fixes.TestStatusBarCompletedFailedP08 object at 0x7b0bd37e03e0&gt;

    def test_status_bar_failed_color(self):
        """Failed status should use red color."""
        from unittest.mock import Mock

&gt;       from frontend.dashboard_manager import DashboardManager

src/tests/unit/test_phase0_fixes.py:209:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     dashboard_manager.py
    # Author:        Paul Calnon
    # Version:       0.2.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #     Dashboard Manager Module
    #
    #     Central coordination hub for all frontend components, managing layout,
    #     routing, and component lifecycle.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################

    import logging
    import os
    import time
    from typing import Any, Dict, List
    from urllib.parse import urljoin

&gt;   import dash
E   ModuleNotFoundError: No module named 'dash'

src/frontend/dashboard_manager.py:42: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_phase0_fixes.TestStatusBarCompletedFailedP08" name="test_failed_takes_priority_over_completed" time="0.002"><failure message="ModuleNotFoundError: No module named 'dash'">self = &lt;src.tests.unit.test_phase0_fixes.TestStatusBarCompletedFailedP08 object at 0x7b0bd3830830&gt;

    def test_failed_takes_priority_over_completed(self):
        """If both failed and completed are True, failed should take priority."""
        from unittest.mock import Mock

&gt;       from frontend.dashboard_manager import DashboardManager

src/tests/unit/test_phase0_fixes.py:233:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     dashboard_manager.py
    # Author:        Paul Calnon
    # Version:       0.2.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    #     Dashboard Manager Module
    #
    #     Central coordination hub for all frontend components, managing layout,
    #     routing, and component lifecycle.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################

    import logging
    import os
    import time
    from typing import Any, Dict, List
    from urllib.parse import urljoin

&gt;   import dash
E   ModuleNotFoundError: No module named 'dash'

src/frontend/dashboard_manager.py:42: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_phase0_fixes.TestNetworkVisualizerDarkModeP07" name="test_stats_bar_dark_mode_background" time="0.001"><failure message="ModuleNotFoundError: No module named 'dash'">self = &lt;src.tests.unit.test_phase0_fixes.TestNetworkVisualizerDarkModeP07 object at 0x7b0bd3b22fd0&gt;

    def test_stats_bar_dark_mode_background(self):
        """Stats bar should have dark background in dark mode."""
&gt;       from dash import Dash
E       ModuleNotFoundError: No module named 'dash'

src/tests/unit/test_phase0_fixes.py:259: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_phase0_fixes.TestNetworkVisualizerDarkModeP07" name="test_stats_bar_light_mode_background" time="0.001" /><testcase classname="src.tests.unit.test_phase0_fixes.TestNetworkVisualizerLegendP09" name="test_legend_position_bottom_left" time="0.002"><failure message="ModuleNotFoundError: No module named 'plotly'">self = &lt;src.tests.unit.test_phase0_fixes.TestNetworkVisualizerLegendP09 object at 0x7b0bd3b23250&gt;
sample_topology = {'connections': [{'from': 'input_0', 'to': 'hidden_0', 'weight': 0.5}, {'from': 'input_1', 'to': 'hidden_0', 'weight': -0.3}, {'from': 'hidden_0', 'to': 'output_0', 'weight': 0.8}], 'hidden_units': 3, 'input_units': 2, 'output_units': 1}

    def test_legend_position_bottom_left(self, sample_topology):
        """Legend should be positioned at bottom-left."""
&gt;       from frontend.components.network_visualizer import NetworkVisualizer

src/tests/unit/test_phase0_fixes.py:317:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     network_visualizer.py
    # Author:        Paul Calnon
    # Version:       1.7.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This file contains the code to Visualize the current Cascade Correlation Neural Network prototype
    #       including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Network Visualizer Component
    #
    # Interactive visualization of the Cascade Correlation network topology,
    # showing input, hidden, and output units with weighted connections.
    # Color-coded by layer and connection strength.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import hashlib
    import json
    import math
    from datetime import datetime
    from typing import Any, Dict, List, Optional, Tuple

    import networkx as nx
&gt;   import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'

src/frontend/components/network_visualizer.py:45: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_phase0_fixes.TestNetworkVisualizerLegendP09" name="test_legend_dark_mode_styling" time="0.002"><failure message="ModuleNotFoundError: No module named 'plotly'">self = &lt;src.tests.unit.test_phase0_fixes.TestNetworkVisualizerLegendP09 object at 0x7b0bd3b23390&gt;
sample_topology = {'connections': [{'from': 'input_0', 'to': 'hidden_0', 'weight': 0.5}, {'from': 'input_1', 'to': 'hidden_0', 'weight': -0.3}, {'from': 'hidden_0', 'to': 'output_0', 'weight': 0.8}], 'hidden_units': 3, 'input_units': 2, 'output_units': 1}

    def test_legend_dark_mode_styling(self, sample_topology):
        """Legend should have dark semi-transparent background in dark mode."""
&gt;       from frontend.components.network_visualizer import NetworkVisualizer

src/tests/unit/test_phase0_fixes.py:332:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     network_visualizer.py
    # Author:        Paul Calnon
    # Version:       1.7.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This file contains the code to Visualize the current Cascade Correlation Neural Network prototype
    #       including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Network Visualizer Component
    #
    # Interactive visualization of the Cascade Correlation network topology,
    # showing input, hidden, and output units with weighted connections.
    # Color-coded by layer and connection strength.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import hashlib
    import json
    import math
    from datetime import datetime
    from typing import Any, Dict, List, Optional, Tuple

    import networkx as nx
&gt;   import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'

src/frontend/components/network_visualizer.py:45: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_phase0_fixes.TestNetworkVisualizerLegendP09" name="test_legend_light_mode_styling" time="0.002"><failure message="ModuleNotFoundError: No module named 'plotly'">self = &lt;src.tests.unit.test_phase0_fixes.TestNetworkVisualizerLegendP09 object at 0x7b0bd37e0510&gt;
sample_topology = {'connections': [{'from': 'input_0', 'to': 'hidden_0', 'weight': 0.5}, {'from': 'input_1', 'to': 'hidden_0', 'weight': -0.3}, {'from': 'hidden_0', 'to': 'output_0', 'weight': 0.8}], 'hidden_units': 3, 'input_units': 2, 'output_units': 1}

    def test_legend_light_mode_styling(self, sample_topology):
        """Legend should have light semi-transparent background in light mode."""
&gt;       from frontend.components.network_visualizer import NetworkVisualizer

src/tests/unit/test_phase0_fixes.py:345:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     network_visualizer.py
    # Author:        Paul Calnon
    # Version:       1.7.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This file contains the code to Visualize the current Cascade Correlation Neural Network prototype
    #       including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Network Visualizer Component
    #
    # Interactive visualization of the Cascade Correlation network topology,
    # showing input, hidden, and output units with weighted connections.
    # Color-coded by layer and connection strength.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import hashlib
    import json
    import math
    from datetime import datetime
    from typing import Any, Dict, List, Optional, Tuple

    import networkx as nx
&gt;   import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'

src/frontend/components/network_visualizer.py:45: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_phase0_fixes.TestNetworkVisualizerLegendP09" name="test_legend_transparency" time="0.002"><failure message="ModuleNotFoundError: No module named 'plotly'">self = &lt;src.tests.unit.test_phase0_fixes.TestNetworkVisualizerLegendP09 object at 0x7b0bd37e0640&gt;
sample_topology = {'connections': [{'from': 'input_0', 'to': 'hidden_0', 'weight': 0.5}, {'from': 'input_1', 'to': 'hidden_0', 'weight': -0.3}, {'from': 'hidden_0', 'to': 'output_0', 'weight': 0.8}], 'hidden_units': 3, 'input_units': 2, 'output_units': 1}

    def test_legend_transparency(self, sample_topology):
        """Legend background should be semi-transparent (alpha &lt; 1.0)."""
&gt;       from frontend.components.network_visualizer import NetworkVisualizer

src/tests/unit/test_phase0_fixes.py:358:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     network_visualizer.py
    # Author:        Paul Calnon
    # Version:       1.7.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This file contains the code to Visualize the current Cascade Correlation Neural Network prototype
    #       including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Network Visualizer Component
    #
    # Interactive visualization of the Cascade Correlation network topology,
    # showing input, hidden, and output units with weighted connections.
    # Color-coded by layer and connection strength.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import hashlib
    import json
    import math
    from datetime import datetime
    from typing import Any, Dict, List, Optional, Tuple

    import networkx as nx
&gt;   import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'

src/frontend/components/network_visualizer.py:45: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_phase0_fixes.TestViewStatePersistenceP05P06" name="test_view_state_store_exists" time="0.002"><failure message="ModuleNotFoundError: No module named 'plotly'">self = &lt;src.tests.unit.test_phase0_fixes.TestViewStatePersistenceP05P06 object at 0x7b0bd3b234d0&gt;

    def test_view_state_store_exists(self):
        """View state store should be present in the layout."""
&gt;       from frontend.components.network_visualizer import NetworkVisualizer

src/tests/unit/test_phase0_fixes.py:380:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     network_visualizer.py
    # Author:        Paul Calnon
    # Version:       1.7.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This file contains the code to Visualize the current Cascade Correlation Neural Network prototype
    #       including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Network Visualizer Component
    #
    # Interactive visualization of the Cascade Correlation network topology,
    # showing input, hidden, and output units with weighted connections.
    # Color-coded by layer and connection strength.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import hashlib
    import json
    import math
    from datetime import datetime
    from typing import Any, Dict, List, Optional, Tuple

    import networkx as nx
&gt;   import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'

src/frontend/components/network_visualizer.py:45: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_phase0_fixes.TestViewStatePersistenceP05P06" name="test_view_state_default_values" time="0.002"><failure message="ModuleNotFoundError: No module named 'plotly'">self = &lt;src.tests.unit.test_phase0_fixes.TestViewStatePersistenceP05P06 object at 0x7b0bd3b23610&gt;

    def test_view_state_default_values(self):
        """View state should have correct default initialization."""
        # Verify the default view state structure is correct in layout definition
&gt;       from frontend.components.network_visualizer import NetworkVisualizer

src/tests/unit/test_phase0_fixes.py:392:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     network_visualizer.py
    # Author:        Paul Calnon
    # Version:       1.7.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This file contains the code to Visualize the current Cascade Correlation Neural Network prototype
    #       including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Network Visualizer Component
    #
    # Interactive visualization of the Cascade Correlation network topology,
    # showing input, hidden, and output units with weighted connections.
    # Color-coded by layer and connection strength.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import hashlib
    import json
    import math
    from datetime import datetime
    from typing import Any, Dict, List, Optional, Tuple

    import networkx as nx
&gt;   import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'

src/frontend/components/network_visualizer.py:45: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_phase0_fixes.TestViewStatePersistenceP05P06" name="test_dragmode_set_to_pan_by_default" time="0.002"><failure message="ModuleNotFoundError: No module named 'plotly'">self = &lt;src.tests.unit.test_phase0_fixes.TestViewStatePersistenceP05P06 object at 0x7b0bd37e0770&gt;

    def test_dragmode_set_to_pan_by_default(self):
        """Default dragmode should be 'pan' for network visualization."""
&gt;       from frontend.components.network_visualizer import NetworkVisualizer

src/tests/unit/test_phase0_fixes.py:405:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     network_visualizer.py
    # Author:        Paul Calnon
    # Version:       1.7.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This file contains the code to Visualize the current Cascade Correlation Neural Network prototype
    #       including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Network Visualizer Component
    #
    # Interactive visualization of the Cascade Correlation network topology,
    # showing input, hidden, and output units with weighted connections.
    # Color-coded by layer and connection strength.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import hashlib
    import json
    import math
    from datetime import datetime
    from typing import Any, Dict, List, Optional, Tuple

    import networkx as nx
&gt;   import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'

src/frontend/components/network_visualizer.py:45: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_phase0_fixes.TestViewStatePersistenceP05P06" name="test_view_state_applied_to_figure" time="0.002"><failure message="ModuleNotFoundError: No module named 'plotly'">self = &lt;src.tests.unit.test_phase0_fixes.TestViewStatePersistenceP05P06 object at 0x7b0bd37e08a0&gt;

    def test_view_state_applied_to_figure(self):
        """View state should be applied to figure when provided."""
&gt;       from frontend.components.network_visualizer import NetworkVisualizer

src/tests/unit/test_phase0_fixes.py:421:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     network_visualizer.py
    # Author:        Paul Calnon
    # Version:       1.7.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This file contains the code to Visualize the current Cascade Correlation Neural Network prototype
    #       including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Network Visualizer Component
    #
    # Interactive visualization of the Cascade Correlation network topology,
    # showing input, hidden, and output units with weighted connections.
    # Color-coded by layer and connection strength.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import hashlib
    import json
    import math
    from datetime import datetime
    from typing import Any, Dict, List, Optional, Tuple

    import networkx as nx
&gt;   import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'

src/frontend/components/network_visualizer.py:45: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_phase0_fixes.TestToolbarButtonsP05" name="test_modebar_config_exists" time="0.002"><failure message="ModuleNotFoundError: No module named 'plotly'">self = &lt;src.tests.unit.test_phase0_fixes.TestToolbarButtonsP05 object at 0x7b0bd3b23750&gt;

    def test_modebar_config_exists(self):
        """Mode bar should be configured in the layout."""
&gt;       from frontend.components.network_visualizer import NetworkVisualizer

src/tests/unit/test_phase0_fixes.py:443:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     network_visualizer.py
    # Author:        Paul Calnon
    # Version:       1.7.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This file contains the code to Visualize the current Cascade Correlation Neural Network prototype
    #       including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Network Visualizer Component
    #
    # Interactive visualization of the Cascade Correlation network topology,
    # showing input, hidden, and output units with weighted connections.
    # Color-coded by layer and connection strength.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import hashlib
    import json
    import math
    from datetime import datetime
    from typing import Any, Dict, List, Optional, Tuple

    import networkx as nx
&gt;   import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'

src/frontend/components/network_visualizer.py:45: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_phase0_fixes.TestToolbarButtonsP05" name="test_modebar_includes_selection_tools" time="0.002"><failure message="ModuleNotFoundError: No module named 'plotly'">self = &lt;src.tests.unit.test_phase0_fixes.TestToolbarButtonsP05 object at 0x7b0bd3b23890&gt;

    def test_modebar_includes_selection_tools(self):
        """Mode bar should include select2d and lasso2d buttons."""
&gt;       from frontend.components.network_visualizer import NetworkVisualizer

src/tests/unit/test_phase0_fixes.py:454:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python
    #####################################################################################################################################################################################################
    # Project:       Juniper
    # Prototype:     Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
    # File Name:     network_visualizer.py
    # Author:        Paul Calnon
    # Version:       1.7.0
    #
    # Date:          2025-10-11
    # Last Modified: 2026-01-07
    #
    # License:       MIT License
    # Copyright:     Copyright (c) 2024-2025 Paul Calnon
    #
    # Description:
    #    This file contains the code to Visualize the current Cascade Correlation Neural Network prototype
    #       including training, state, and architecture with the Juniper prototype Frontend for monitoring and diagnostics.
    #
    #####################################################################################################################################################################################################
    # Notes:
    #
    # Network Visualizer Component
    #
    # Interactive visualization of the Cascade Correlation network topology,
    # showing input, hidden, and output units with weighted connections.
    # Color-coded by layer and connection strength.
    #
    #####################################################################################################################################################################################################
    # References:
    #
    #####################################################################################################################################################################################################
    # TODO :
    #
    #####################################################################################################################################################################################################
    # COMPLETED:
    #
    #####################################################################################################################################################################################################
    import hashlib
    import json
    import math
    from datetime import datetime
    from typing import Any, Dict, List, Optional, Tuple

    import networkx as nx
&gt;   import plotly.graph_objects as go
E   ModuleNotFoundError: No module named 'plotly'

src/frontend/components/network_visualizer.py:45: ModuleNotFoundError</failure></testcase><testcase classname="src.tests.unit.test_training_state_machine.TestTrainingStateMachineBasics" name="test_initial_state" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestTrainingStateMachineBasics" name="test_get_state_summary" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestValidTransitions" name="test_valid_transition[TrainingStatus.STOPPED-Command.START-TrainingStatus.STARTED-TrainingPhase.OUTPUT]" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestValidTransitions" name="test_valid_transition[TrainingStatus.STOPPED-Command.RESET-TrainingStatus.STOPPED-TrainingPhase.IDLE]" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestValidTransitions" name="test_valid_transition[TrainingStatus.STARTED-Command.PAUSE-TrainingStatus.PAUSED-TrainingPhase.OUTPUT]" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestValidTransitions" name="test_valid_transition[TrainingStatus.STARTED-Command.STOP-TrainingStatus.STOPPED-TrainingPhase.IDLE]" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestValidTransitions" name="test_valid_transition[TrainingStatus.STARTED-Command.RESET-TrainingStatus.STOPPED-TrainingPhase.IDLE]" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestValidTransitions" name="test_valid_transition[TrainingStatus.PAUSED-Command.RESUME-TrainingStatus.STARTED-TrainingPhase.OUTPUT]" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestValidTransitions" name="test_valid_transition[TrainingStatus.PAUSED-Command.START-TrainingStatus.STARTED-TrainingPhase.OUTPUT]" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestValidTransitions" name="test_valid_transition[TrainingStatus.PAUSED-Command.STOP-TrainingStatus.STOPPED-TrainingPhase.IDLE]" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestValidTransitions" name="test_valid_transition[TrainingStatus.PAUSED-Command.RESET-TrainingStatus.STOPPED-TrainingPhase.IDLE]" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestInvalidTransitions" name="test_invalid_transition[TrainingStatus.STOPPED-Command.PAUSE]" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestInvalidTransitions" name="test_invalid_transition[TrainingStatus.STOPPED-Command.RESUME]" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestInvalidTransitions" name="test_invalid_transition[TrainingStatus.STOPPED-Command.STOP]" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestInvalidTransitions" name="test_invalid_transition[TrainingStatus.STARTED-Command.START]" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestInvalidTransitions" name="test_invalid_transition[TrainingStatus.STARTED-Command.RESUME]" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestInvalidTransitions" name="test_invalid_transition[TrainingStatus.PAUSED-Command.PAUSE]" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestPauseResumeBehavior" name="test_pause_saves_output_phase" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestPauseResumeBehavior" name="test_pause_saves_candidate_phase" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestPauseResumeBehavior" name="test_resume_restores_output_phase" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestPauseResumeBehavior" name="test_resume_restores_candidate_phase" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestPauseResumeBehavior" name="test_start_when_paused_acts_as_resume" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestCandidatePhaseHandling" name="test_save_candidate_state" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestCandidatePhaseHandling" name="test_candidate_state_persists_across_pause_resume" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestCandidatePhaseHandling" name="test_candidate_state_cleared_on_reset" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestCandidatePhaseHandling" name="test_candidate_state_cleared_on_stop" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestPhaseTransitions" name="test_set_phase_when_started" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestPhaseTransitions" name="test_set_phase_when_not_started_ignored" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestRapidCommandSequences" name="test_rapid_start_stop_start" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestRapidCommandSequences" name="test_rapid_pause_resume_pause" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestRapidCommandSequences" name="test_reset_from_any_state" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestResetBehavior" name="test_reset_clears_all_state" time="0.001" /><testcase classname="src.tests.unit.test_training_state_machine.TestResetBehavior" name="test_reset_always_succeeds" time="0.002" /></testsuite></testsuites>
