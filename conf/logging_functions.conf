#!/usr/bin/env bash
#####################################################################################################################################################################################################
# Project:       Juniper
# Sub-Project:   JuniperCanopy
# Application:   juniper_canopy
# Purpose:       Monitoring and Diagnostic Frontend for Cascade Correlation Neural Network
#
# Author:        Paul Calnon
# Version:       0.1.4 (0.7.3)
# File Name:     init_fn.conf
# File Path:     <Project>/<Sub-Project>/<Application>/conf/
#
# Date:          2025-12-18
# Last Modified: 2025-12-19
#
# License:       MIT License
# Copyright:     Copyright (c) 2024,2025,2026 Paul Calnon
#
# Description:
#    This config file defines the functions needed by the initialization config file for the Juniper Project's juniper_canopy prototype
#    Warning:  This Script / Config file is sourced by the init.conf script
#
#####################################################################################################################################################################################################
# Notes:
#     Warning:  This Config file is sourced by the init.conf script which, itself, is sourced by all Juniper Canopy util scripts including the try.bash and get_code_stats.bash scripts
#
#####################################################################################################################################################################################################
# References:
#
#####################################################################################################################################################################################################
# TODO :
#
#####################################################################################################################################################################################################
# COMPLETED:
#
#####################################################################################################################################################################################################


#####################################################################################################################################################################################################
# Define Debug Constants
#####################################################################################################################################################################################################
export TRUE="0"
export FALSE="1"

# export DEBUG="${TRUE}"
export DEBUG="${FALSE}"


# #####################################################################################################################################################################################################
# # Check if this config file has already been sourced.  Only Source this conf file Once
# #####################################################################################################################################################################################################
if [[ "${JUNIPER_INIT_FN_CONF_SOURCED}" != "${TRUE}" ]]; then
    export JUNIPER_INIT_FN_CONF_SOURCED="${TRUE}"
else
    log_warning "init_fn.conf already sourced.  Skipping re-source."
    [[ "${DEBUG}" == "${TRUE}" ]] && exit $(( TRUE )) || return $(( TRUE ))
fi


# #####################################################################################################################################################################################################
# # use these functions to update the calling script id
# #####################################################################################################################################################################################################
# function update_calling_script_id() {
#     SCRIPT_NAME_ID=$(( SCRIPT_NAME_ID + 1))
#     LINE_NO_ID=$(( LINE_NO_ID + 1))
#     FUNC_NAME_ID=$(( FUNC_NAME_ID + 1 ))
# }


# #####################################################################################################################################################################################################
# # Helper functions that retrieve and validate init conf, calling script, and logging environment information
# #####################################################################################################################################################################################################
# function get_calling_script_info() {
#     SCRIPT_NAME_ID="$1"
#     CALLING_PATH="$(realpath ${BASH_SOURCE[${SCRIPT_NAME_ID}]})"
#     CALLING_DIR="$(dirname ${CALLING_PATH})"
# }

# function get_application_info() {
#     CALLING_PATH="$1"
#     APP_DIR="$(dirname "${CALLING_PATH}")"
#     APP_NAME="$(basename "${APP_DIR}")"
# }

# function get_logs_dir() {
#     APP_PATH="$1"
#     LOGGING_DIR_NAME="$2"
#     LOG_DIR="$(dirname "${APP_PATH}")/${LOGGING_DIR_NAME}"
#     [[ ! -d "${LOG_DIR}" ]] && mkdir -p "${LOG_DIR}"
# }

# function get_unique_log_label() {
#     UNIQUE_LABEL="_$(date +%F_%T)"
# }

# function get_log_filename() {
#     FILE_NAME="$1"
#     FILE_EXT="$2"
#     UNIQUE_LABEL="$3"
#     LOG_FILENAME="${FILE_NAME}${UNIQUE_LABEL}.${FILE_EXT}"
# }

# function check_filename(){
#     FILENAME="$1"
#     DIR_NAME="$2"
#     [[ -f "${DIR_NAME}/${FILENAME}" ]] && return $(( TRUE )) || return $(( FALSE ))
# }

# function get_valid_filename() {
#     APP_NAME="$1"
#     LOG_EXT="$2"
#     LOGGING_DIR="$3"
#     get_log_filename "${APP_NAME}" "${LOG_EXT}"
#     if ! check_filename "${LOG_FILENAME}" "${LOGGING_DIR}"; then
#         UNIQUE_LABEL="" && get_unique_log_label
#         get_log_filename "${LOG_FILENAME%.*}" "${LOG_FILENAME##*.}" "${UNIQUE_LABEL}"
#     fi
# }

# function get_log_file() {
#     APP_NAME="$1"
#     APP_DIR="$2"
#     LOG_EXT="$3"
#     LOG_DIR_NAME="$4"
#     get_logs_dir "${APP_DIR}" "${LOG_DIR_NAME}"
#     get_valid_filename "${APP_NAME}" "${LOG_EXT}" "${LOG_DIR}"
#     LOG_FILE="${LOG_DIR}/${LOG_FILENAME}"
# }

# function get_log_env_info() {
#     LOG_EXT="$1"
#     LOGGING_DIR="$2"
#     SCRIPT_NAME_ID="$3"
#     get_calling_script_info "${SCRIPT_NAME_ID}"
#     get_application_info "${CALLING_DIR}"
#     get_log_file "${APP_NAME}" "${APP_DIR}" "${LOG_EXT}" "${LOG_DIR_NAME}"
# }

# function get_log_header_info() {
#     SCRIPT_NAME_ID="$1"
#     LINE_NO_ID="$2"
#     FUNC_NAME_ID="$3"
#     CALLING_PATH="$(realpath ${BASH_SOURCE[${SCRIPT_NAME_ID}]})"
#     CALLING_SCRIPT="$(basename "${CALLING_PATH}")"
#     CALLING_LINE="${BASH_LINENO[${LINE_NO_ID}]}"
#     CALLING_FUNC="${FUNCNAME[${FUNC_NAME_ID}]}"
# }

# function get_init_script_info() {
#     CURRENT_SCRIPT_ID="$1"
#     CURRENT_FUNC_ID="$2"
#     CURRENT_PATH="$(realpath "${BASH_SOURCE[${CURRENT_SCRIPT_ID}]}")"
#     CURRENT_SCRIPT="$(basename "${CURRENT_PATH}")"
#     CURRENT_DIR="$(dirname "${CURRENT_PATH}")"
#     CURRENT_LINE="${LINENO}"
#     CURRENT_FUNC="${FUNCNAME[${CURRENT_FUNC_ID}]}"
# }

# function get_log_color_info() {
#     export BLACK_BOLD_DARK="\033[2;90m"
#     export BLACK_BOLD="\033[0;90m"
#     export BLUE_BRIGHT="\033[1;34m"
#     export GREEN="\033[0;32m"
#     export YELLOW_BOLD="\033[0;93m"
#     export RED_BRIGHT="\033[1;31m"
#     export WHITE_BOLD_ON_RED="\033[0;97;41m"
#     export WHITE_BOLD_BRIGHT_ON_RED="\033[1;97;41m"
#     export RESET="\033[0m"

#     export COLOR_TRACE="${BLACK_BOLD_DARK}"
#     export COLOR_VERBOSE="${BLACK_BOLD}"
#     export COLOR_DEBUG="${BLUE_BRIGHT}"
#     export COLOR_INFO="${GREEN}"
#     export COLOR_WARNING="${YELLOW_BOLD}"
#     export COLOR_ERROR="${RED_BRIGHT}"
#     export COLOR_CRITICAL="${WHITE_ON_RED}"
#     export COLOR_FATAL="${WHITE_BOLD_BRIGHT_ON_RED}"
# }

# function get_logging_env() {
#     # echo "get_logging_env"
#     # echo "get_log_env_info"
#     get_log_env_info "${LOG_EXT}" "${LOGS_DIR}" "${SCRIPT_NAME_ID}"
#     # echo "log_header_info"
#     get_log_header_info "${SCRIPT_NAME_ID}" "${LINE_NO_ID}" "${FUNC_NAME_ID}"
#     # echo "init_script_info"
#     get_init_script_info "${SCRIPT_NAME_ID}" "${FUNC_NAME_ID}"
#     # echo "log_color_info"
#     get_log_color_info
#     # echo "Completed get_logging_env"
# }


#####################################################################################################################################################################################################
# Export Function Definitions
#####################################################################################################################################################################################################
export -f get_calling_script_info
export -f get_application_info
export -f get_logs_dir
export -f get_unique_log_label
export -f get_log_filename
export -f check_filename
export -f get_valid_filename
export -f get_log_file
export -f get_log_env_info
export -f get_log_header_info
export -f get_init_script_info
export -f get_log_color_info
export -f get_logging_env


#####################################################################################################################################################################################################
# Define global, exported functions for safe logging
#####################################################################################################################################################################################################
function is_defined() {
    declare -F $1 &> /dev/null
}


# TODO: fix calling script name, line number, and function
function log_trace() {
    MESSAGE="$1"
    [[ "${2}" != "" ]] && EXIT_STATUS="$2" || EXIT_STATUS="${TRUE}"
    [[ "${3}" != "" ]] && TERM_STATUS="$3" || TERM_STATUS="${FALSE}"

    # # update_calling_script_id
    # for (( i=0; i<${#BASH_SOURCE[@]}; i++ )); do
    #     echo "Bash Source[$i]: \"${BASH_SOURCE[$i]}\""
    # done
    # for (( i=0; i<${#BASH_LINENO[@]}; i++ )); do
    #     echo "Bash Line No[$i]: \"${BASH_LINENO[$i]}\""
    # done
    # for (( i=0; i<${#FUNCNAME[@]}; i++ )); do
    #     echo "Bash Func Name[$i]: \"${FUNCNAME[$i]}\""
    # done

    is_defined global_log_trace && { global_log_trace "$@" "${EXIT_STATUS}" "${TERM_STATUS}"; SUCCESS="$?"; return $(( SUCCESS )); }
    get_logging_env
    printf "%b%-21s %-28s %-21s %-11s %s%b\n" "${COLOR_TRACE}" "($(date +%F_%T))" "${CALLING_SCRIPT}:${CALLING_LINE})" "${CALLING_FUNC}:" "[TRACE]" "${MESSAGE}" "${RESET}" | tee -a "${LOG_FILE}" 2>&1
    [[ "${TERM_STATUS}" == "${TRUE}" ]] && { set -e; exit $(( EXIT_STATUS )); } || return $(( EXIT_STATUS ))
}

function log_verbose() {
    MESSAGE="$1"
    [[ "${2}" != "" ]] && EXIT_STATUS="$2" || EXIT_STATUS="${TRUE}"
    [[ "${3}" != "" ]] && TERM_STATUS="$3" || TERM_STATUS="${FALSE}"
    is_defined global_log_verbose && { global_log_verbose "$@" "${EXIT_STATUS}" "${TERM_STATUS}"; SUCCESS="$?"; return $(( SUCCESS )); }
    get_logging_env
    printf "%b%-21s %-28s %-21s %-11s %s%b\n" "${COLOR_VERBOSE}" "($(date +%F_%T))" "${CALLING_SCRIPT}:${CALLING_LINE})" "${CALLING_FUNC}:" "[VERBOSE]" "${MESSAGE}" "${RESET}" | tee -a "${LOG_FILE}" 2>&1
    [[ "${TERM_STATUS}" == "${TRUE}" ]] && { set -e; exit $(( EXIT_STATUS )); } || return $(( EXIT_STATUS ))
}

function log_debug() {
    MESSAGE="$1"
    [[ "${2}" != "" ]] && EXIT_STATUS="$2" || EXIT_STATUS="${TRUE}"
    [[ "${3}" != "" ]] && TERM_STATUS="$3" || TERM_STATUS="${FALSE}"
    is_defined global_log_debug && { global_log_debug "$@" "${EXIT_STATUS}" "${TERM_STATUS}"; SUCCESS="$?"; return $(( SUCCESS )); }
    get_logging_env
    printf "%b%-21s %-28s %-21s %-11s %s%b\n" "${COLOR_DEBUG}" "($(date +%F_%T))" "${CALLING_SCRIPT}:${CALLING_LINE})" "${CALLING_FUNC}:" "[DEBUG]" "${MESSAGE}" "${RESET}" | tee -a "${LOG_FILE}" 2>&1
    [[ "${TERM_STATUS}" == "${TRUE}" ]] && { set -e; exit $(( EXIT_STATUS )); } || return $(( EXIT_STATUS ))
}

function log_info() {
    MESSAGE="$1"
    [[ "${2}" != "" ]] && EXIT_STATUS="$2" || EXIT_STATUS="${TRUE}"
    [[ "${3}" != "" ]] && TERM_STATUS="$3" || TERM_STATUS="${FALSE}"
    is_defined global_log_info && { global_log_info "$@" "${EXIT_STATUS}" "${TERM_STATUS}"; SUCCESS="$?"; return $(( SUCCESS )); }
    get_logging_env
    printf "%b%-21s %-28s %-21s %-11s %s%b\n" "${COLOR_INFO}" "($(date +%F_%T))" "${CALLING_SCRIPT}:${CALLING_LINE})" "${CALLING_FUNC}:" "[INFO]" "${MESSAGE}" "${RESET}" | tee -a "${LOG_FILE}" 2>&1
    [[ "${TERM_STATUS}" == "${TRUE}" ]] && { set -e; exit $(( EXIT_STATUS )); } || return $(( EXIT_STATUS ))
}

function log_warning() {
    MESSAGE="$1"
    [[ "${2}" != "" ]] && EXIT_STATUS="$2" || EXIT_STATUS="${TRUE}"
    [[ "${3}" != "" ]] && TERM_STATUS="$3" || TERM_STATUS="${FALSE}"
    is_defined global_log_warning && { global_log_warning "$@" "${EXIT_STATUS}" "${TERM_STATUS}"; SUCCESS="$?"; return $(( SUCCESS )); }
    get_logging_env
    printf "%b%-21s %-28s %-21s %-11s %s%b\n" "${COLOR_WARNING}" "($(date +%F_%T))" "${CALLING_SCRIPT}:${CALLING_LINE})" "${CALLING_FUNC}:" "[WARNING]" "${MESSAGE}" "${RESET}" | tee -a "${LOG_FILE}" 2>&1
    [[ "${TERM_STATUS}" == "${TRUE}" ]] && { set -e; exit $(( EXIT_STATUS )); } || return $(( EXIT_STATUS ))
}

function log_error() {
    MESSAGE="$1"
    [[ "${2}" != "" ]] && EXIT_STATUS="$2" || EXIT_STATUS="${FALSE}"
    [[ "${3}" != "" ]] && TERM_STATUS="$3" || TERM_STATUS="${FALSE}"
    is_defined global_log_error && { global_log_error "$@" "${EXIT_STATUS}" "${TERM_STATUS}"; SUCCESS="$?"; return $(( SUCCESS )); }
    get_logging_env
    printf "%b%-21s %-28s %-21s %-11s %s%b\n" "${COLOR_ERROR}" "($(date +%F_%T))" "${CALLING_SCRIPT}:${CALLING_LINE})" "${CALLING_FUNC}:" "[ERROR]" "${MESSAGE}" "${RESET}" | tee -a "${LOG_FILE}" 2>&1
    [[ "${TERM_STATUS}" == "${TRUE}" ]] && { set -e; exit $(( EXIT_STATUS )); } || return $(( EXIT_STATUS ))
}

function log_critical() {
    MESSAGE="$1"
    [[ "${2}" != "" ]] && EXIT_STATUS="$2" || EXIT_STATUS="${FALSE}"
    [[ "${3}" != "" ]] && TERM_STATUS="$3" || TERM_STATUS="${TRUE}"
    is_defined global_log_critical && { global_log_critical "$@" "${EXIT_STATUS}" "${TERM_STATUS}"; SUCCESS="$?"; return $(( SUCCESS )); }
    get_logging_env
    printf "%b%-21s %-28s %-21s %-11s %s%b\n" "${COLOR_CRITICAL}" "($(date +%F_%T))" "${CALLING_SCRIPT}:${CALLING_LINE})" "${CALLING_FUNC}:" "[CRITICAL]" "${MESSAGE}" "${RESET}" | tee -a "${LOG_FILE}" 2>&1
    [[ "${TERM_STATUS}" == "${TRUE}" ]] && { set -e; exit $(( EXIT_STATUS )); } || return $(( EXIT_STATUS ))
}

function log_fatal() {
    MESSAGE="$1"
    [[ "${2}" != "" ]] && EXIT_STATUS="$2" || EXIT_STATUS="${FALSE}"
    [[ "${3}" != "" ]] && TERM_STATUS="$3" || TERM_STATUS="${TRUE}"
    is_defined global_log_fatal && { global_log_fatal "$@" "${EXIT_STATUS}" "${TERM_STATUS}"; SUCCESS="$?"; return $(( SUCCESS )); }
    get_logging_env
    printf "%b%-21s %-28s %-21s %-11s %s%b\n" "${COLOR_FATAL}" "($(date +%F_%T))" "${CALLING_SCRIPT}:${CALLING_LINE})" "${CALLING_FUNC}:" "[FATAL]" "${MESSAGE}" "${RESET}" | tee -a "${LOG_FILE}" 2>&1
    [[ "${TERM_STATUS}" == "${TRUE}" ]] && { set -e; exit $(( EXIT_STATUS )); } || return $(( EXIT_STATUS ))
}


#####################################################################################################################################################################################################
# Export Function Definitions
#####################################################################################################################################################################################################
export -f is_defined
export -f log_trace
export -f log_verbose
export -f log_debug
export -f log_info
export -f log_warning
export -f log_error
export -f log_critical
export -f log_fatal


[[ "${DEBUG}" == "${TRUE}" ]] && exit $(( TRUE )) || return $(( TRUE ))
